<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
   <TITLE>AptStepMaker Programming Class</TITLE>
   <link rel="stylesheet" type="text/css" href="pkgcss/style.css" media = 'screen'>
</HEAD>

<BODY onload='onrun();'>
  <script type="text/javascript" src="pkgcss/tabs.js"></script>
<TABLE class=pagehead><TR>
<TD class=logo>AptStepMaker</TD>
<TD class=quicklinks>
  <A HREF="http://www.steptools.com">[www.steptools.com]</a>
  <A HREF="../index.html">[STEP-NC Home]</A>
  <A HREF="index.html">[STEP-NC API Guide]</A>
</TD></TR>
</TABLE>

<div class=bktoc>
<FORM class=bksearch method=GET action="http://www.google.com/search">
Search STEP Tools Web Support<br>
<INPUT TYPE=text name=q size=22 maxlength=255 value="">
<INPUT TYPE=hidden name=q value="site:www.steptools.com/support">
<INPUT class=button type=submit name=sa VALUE="Google">
</FORM>
<ul>
<li><a href="#oview">Overview</a>
<li><a href="#ids">A Note on Identifiers</a>
<li><a href="#ArcABC">ArcABC()</a>
<li><a href="#ArcGeneralPlane">ArcGeneralPlane()</a>
<li><a href="#ArcRefABC">ArcRefABC()</a>
<li><a href="#Arc">ArcXYPlane(), ArcYZPlane(), ArcZXPlane()</a>
<li><a href="#CamModeOn">CamModeOn/Off()</a>
<li><a href="#CenterOn">CenterOn()</a>
<li><a href="#ChangeWorkingstepTool">ChangeWorkingstepTool()</a>
<li><a href="#CircleGeneralPlane">CircleGeneralPlane()</a>
<li><a href="#CircleXYPlane">CircleXYPlane()</a>
<li><a href="#CircleYZPlane">CircleYZPlane()</a>
<li><a href="#CircleZXPlane">CircleZXPlane()</a>
<li><a href="#Clean">Clean()</a>
<li><a href="#ClearancePlane">ClearancePlane()</a>
<li><a href="#CompressTechnology">CompressTechnology()</a>
<li><a href="#Connector">Connector()</a>
<li><a href="#ContactOn">ContactOn()</a>
<li><a href="#CoolantOn">CoolantOn/Off/Mist/Thru()</a>
<li><a href="#CutterDiameterCompensationAssignment">CutterDiameterCompensationAssignment()</a>
<li><a href="#DefaultToInches">DefaultToInches() / DefaultToMillimeters()</a>
<li><a href="#DefineTool">DefineTool()</a>
<li><a href="#DefineToolCoolantThrough">DefineToolCoolantThrough()</a>
<li><a href="#DefineToolDrill">DefineToolDrill()</a>
<li><a href="#DefineToolEndmill">DefineToolEndmill()</a>
<li><a href="#DefineToolFacemill">DefineToolFacemill()</a>
<li><a href="#DefineToolFeedAndSpeed">DefineToolFeedAndSpeed()</a>
<li><a href="#DefineToolHandOfCut">DefineToolHandOfCut()</a>
<li><a href="#DefineToolMaterial">DefineToolMaterial()</a>
<li><a href="#DefineToolRadius">DefineToolRadius()</a>
<li><a href="#DefineToolRotatingBoringCuttingTool">DefineToolRotatingBoringCuttingTool()</a>
<li><a href="#DefineToolSpotDrill">DefineToolSpotDrill()</a>
<li><a href="#DefineToolStraightReamer">DefineToolStraightReamer()</a>
<li><a href="#DefineToolTapping">DefineToolTapping()</a>
<li><a href="#DeleteAllUnusedTools">DeleteAllUnusedTools()</a>
<li><a href="#DeleteAllUnusedWorkpieces">DeleteAllUnusedWorkpieces()</a>
<li><a href="#DeleteExecutable">DeleteExecutable()</a>
<li><a href="#DeleteFixture">DeleteFixture()</a>
<li><a href="#DeleteToolParameters">DeleteToolParameters()</a>
<li><a href="#DeleteWorkpiece">DeleteWorkpiece()</a>
<li><a href="#EditAddPoint">EditAddPoint()</a>
<li><a href="#EditChangePoint">EditChangePoint()</a>
<li><a href="#EmptyOperation">EmptyOperation()</a>
<li><a href="#EndWorkplan">EndWorkplan()</a>
<li><a href="#EstimateDepths">EstimateDepths()</a>
<li><a href="#ExecutableMoveAfter">ExecutableMoveAfter()</a>
<li><a href="#ExecutableReuse">ExecutableReuse()</a>
<li><a href="#ExecutableReuseAfter">ExecutableReuseAfter()</a>
<li><a href="#ExecutableToSelective">ExecutableToSelective()</a>
<li><a href="#ExecutableWorkpieceAsIs">ExecutableWorkpieceAsIs()</a>
<li><a href="#ExecutableWorkpieceRemoval">ExecutableWorkpieceRemoval()</a>
<li><a href="#ExecutableWorkpieceReuseAsIs">ExecutableWorkpieceReuseAsIs()</a>
<li><a href="#ExecutableWorkpieceReuseRemoval">ExecutableWorkpieceReuseRemoval()</a>
<li><a href="#ExecutableWorkpieceReuseToBe">ExecutableWorkpieceReuseToBe()</a>
<li><a href="#ExecutableWorkpieceToBe">ExecutableWorkpieceToBe()</a>
<li><a href="#ExportAP238CC1">ExportAP238CC1()</a>
<li><a href="#ExportAsAPT">ExportAsAPT()</a>
<li><a href="#ExportAsDmisCNC">ExportAsDmisCNC()</a>
<li><a href="#ExportAsDmisManual">ExportAsDmisManual()</a>
<li><a href="#ExportAsESAB">ExportAsESAB()</a>
<li><a href="#ExportAsFanuc">ExportAsFanuc()</a>
<li><a href="#ExportAsHaas">ExportAsHaas()</a>
<li><a href="#ExportAsHeidenhainAC">ExportAsHeidenhainAC()</a>
<li><a href="#ExportAsHeidenhainBC">ExportAsHeidenhainBC()</a>
<li><a href="#ExportAsMDSI">ExportAsMDSI()</a>
<li><a href="#ExportAsOkuma">ExportAsOkuma()</a>
<li><a href="#ExportAsSiemens">ExportAsSiemens()</a>
<li><a href="#ExportCNC">ExportCNC()</a>
<li><a href="#ExportWorkpiece">ExportWorkpiece()</a>
<li><a href="#ExtendedNcFunction">ExtendedNcFunction()</a>
<li><a href="#ExtendedNcFunctionAfter">ExtendedNcFunctionAfter()</a>
<li><a href="#ExternalOperation">ExternalOperation()</a>
<li><a href="#Feedrate">Feedrate()</a>
<li><a href="#FeedrateCSS">FeedrateCSS()</a>
<li><a href="#FeedrateUnit">FeedrateUnit()</a>
<li><a href="#FirstPathStartAxis">FirstPathStartAxis()</a>
<li><a href="#FirstPathStartPoint">FirstPathStartPoint()</a>
<li><a href="#Fixture">Fixture()</a>
<li><a href="#GenerateToolGeometry">GenerateToolGeometry()</a>
<li><a href="#GeometryForTool">GeometryForTool()</a>
<li><a href="#GeometryForToolNumber">GeometryForToolNumber()</a>
<li><a href="#GetCNCexportActualFlutes">GetCNCexportActualFlutes()</a>
<li><a href="#GetCNCexportExecIsEnabled">GetCNCexportExecIsEnabled()</a>
<li><a href="#GetCNCexportExecSpeedprofileActive">GetCNCexportExecSpeedprofileActive()</a>
<li><a href="#GetCurrentFeed">GetCurrentFeed()</a>
<li><a href="#GetCurrentFixture">GetCurrentFixture()</a>
<li><a href="#GetCurrentFunction">GetCurrentFunction()</a>
<li><a href="#GetCurrentLastExecutable">GetCurrentLastExecutable()</a>
<li><a href="#GetCurrentLocation">GetCurrentLocation()</a>
<li><a href="#GetCurrentNormals">GetCurrentNormals()</a>
<li><a href="#GetCurrentProject">GetCurrentProject()</a>
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece()</a>
<li><a href="#GetCurrentSpeed">GetCurrentSpeed()</a>
<li><a href="#GetCurrentTech">GetCurrentTech()</a>
<li><a href="#GetCurrentTool">GetCurrentTool()</a>
<li><a href="#GetCurrentToolpath">GetCurrentToolpath()</a>
<li><a href="#GetCurrentWorkingstep">GetCurrentWorkingstep()</a>
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece()</a>
<li><a href="#GetCurrentWorkplan">GetCurrentWorkplan()</a>
<li><a href="#GetExecutableIsEnabled">GetExecutableIsEnabled()</a>
<li><a href="#GetExecutableIsReachable">GetExecutableIsReachable()</a>
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs()</a>
<li><a href="#GetExecutableWorkpieceFixture">GetExecutableWorkpieceFixture()</a>
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval()</a>
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe()</a>
<li><a href="#GetExecutableWorkpieceTool">GetExecutableWorkpieceTool()</a>
<li><a href="#GetFrameDefinitionAllNext">GetFrameDefinitionAllNext()</a>
<li><a href="#GetFrameDefinitionBestGuessForExecutable">GetFrameDefinitionBestGuessForExecutable()</a>
<li><a href="#GetFrameDefinitionCount">GetFrameDefinitionCount()</a>
<li><a href="#GetSetupAllCount">GetSetupAllCount/Next()</a>
<li><a href="#GetSetupBestGuessForExecutable">GetSetupBestGuessForExecutable()</a>
<li><a href="#GetToolId">GetToolId()</a>
<li><a href="#GetToolIdentifier">GetToolIdentifier()</a>
<li><a href="#GetToolNumber">GetToolNumber()</a>
<li><a href="#GetUUID">GetUUID()</a>
<li><a href="#GetWorkpieceExecutableCount">GetWorkpieceExecutableCount/Next()</a>
<li><a href="#GetWorkpiecePlacement">GetWorkpiecePlacement()</a>
<li><a href="#GetWorkpieceShapeCount">GetWorkpieceShapeCount/Next()</a>
<li><a href="#GoHome">GoHome()</a>
<li><a href="#GoHomeAfter">GoHomeAfter()</a>
<li><a href="#GoToXYZ">GoToXYZ()</a>
<li><a href="#GoToXYZ_ABC">GoToXYZ_ABC()</a>
<li><a href="#GoToXYZ_IJK">GoToXYZ_IJK()</a>
<li><a href="#GoToXYZ_IJK_ABC">GoToXYZ_IJK_ABC()</a>
<li><a href="#GoToXYZ_IJK_REF_ABC">GoToXYZ_IJK_REF_ABC()</a>
<li><a href="#ImportFanuc">ImportFanuc()</a>
<li><a href="#ImportHaas">ImportHaas()</a>
<li><a href="#ImportSiemens">ImportSiemens()</a>
<li><a href="#ImportToolParametersFromSTRL">ImportToolParametersFromSTRL()</a>
<li><a href="#ImportWorkingstepOperationFromSTRL">ImportWorkingstepOperationFromSTRL()</a>
<li><a href="#ImportWorkingstepPaths">ImportWorkingstepPaths()</a>
<li><a href="#ImportWorkpiecesFromSTRL">ImportWorkpiecesFromSTRL()</a>
<li><a href="#ImportWorkplanFromFile">ImportWorkplanFromFile()</a>
<li><a href="#ImportWorkplanFromSTRL">ImportWorkplanFromSTRL()</a>
<li><a href="#Inches">Inches()</a>
<li><a href="#IndexTable">IndexTable()</a>
<li><a href="#IndexTableAfter">IndexTableAfter()</a>
<li><a href="#IsToolDefined">IsToolDefined()</a>
<li><a href="#Left">Left()</a>
<li><a href="#LoadTool">LoadTool()</a>
<li><a href="#LoadToolWithLength">LoadToolWithLength()</a>
<li><a href="#MergeFollowingWorkingstep">MergeFollowingWorkingstep()</a>
<li><a href="#MergeFollowingWorkingstepAll">MergeFollowingWorkingstepAll()</a>
<li><a href="#MergeWorkingstep">MergeWorkingstep()</a>
<li><a href="#Millimeters">Millimeters()</a>
<li><a href="#MultaxOff">MultaxOn/Off()</a>
<li><a href="#NestSelectiveAfter">NestSelectiveAfter()</a>
<li><a href="#NestWorkplan">NestWorkplan()</a>
<li><a href="#NestWorkplanAfter">NestWorkplanAfter()</a>
<li><a href="#NewProject">NewProject()</a>
<li><a href="#NewProjectWithCCandWP">NewProjectWithCCandWP()</a>
<li><a href="#Open224">Open224()</a>
<li><a href="#Open224andMakeWorkingSteps">Open224andMakeWorkingSteps()</a>
<li><a href="#Open238">OpenProject()/OpenSTEPNC()/Open238()</a>
<li><a href="#OpenCheckSTRL">OpenCheckSTRL()</a>
<li><a href="#OpenSTEP">OpenSTEP()</a>
<li><a href="#OpenUsingSTRL">OpenUsingSTRL()</a>
<li><a href="#OptionalStop">OptionalStop()</a>
<li><a href="#OptionalStopAfter">OptionalStopAfter()</a>
<li><a href="#PartNo">PartNo()</a>
<li><a href="#PPrint">PPrint()</a>
<li><a href="#PPrintAfter">PPrintAfter()</a>
<li><a href="#ProbeOperation">ProbeOperation()</a>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement()</a>
<li><a href="#Rapid">Rapid()</a>
<li><a href="#Rawpiece">Rawpiece()</a>
<li><a href="#RawpieceOfWorkpiece">RawpieceOfWorkpiece()</a>
<li><a href="#ReadCatiaAPTclfile">ReadCatiaAPTclfile()</a>
<li><a href="#ReadCatiaAptPlateClfile">ReadCatiaAptPlateClfile()</a>
<li><a href="#ReadMax5APTclfile">ReadMax5APTclfile()</a>
<li><a href="#ReadProeAPTclfile">ReadProeAPTclfile()</a>
<li><a href="#ReadUgsAPTclfile">ReadUgsAPTclfile()</a>
<li><a href="#ReplaceMax5APTclfile">ReplaceMax5APTclfile()</a>
<li><a href="#Reset">Reset()</a>
<li><a href="#RetractPlane">RetractPlane()</a>
<li><a href="#ReuseFixtureReference">ReuseFixtureReference()</a>
<li><a href="#Right">Right()</a>
<li><a href="#RunConfiguration">RunConfiguration()</a>
<li><a href="#SaveAsModules">SaveAsModules()</a>
<li><a href="#SaveAsModulesWithSTRL">SaveAsModulesWithSTRL()</a>
<li><a href="#SaveAsP21">SaveAsP21()</a>
<li><a href="#SaveAsP21WithSTRL">SaveAsP21WithSTRL()</a>
<li><a href="#SaveFastAsModules">SaveFastAsModules()</a>
<li><a href="#SaveFastAsP21">SaveFastAsP21()</a>
<li><a href="#SecondProject">SecondProject()</a>
<li><a href="#SecondProjectTransform">SecondProjectTransform()</a>
<li><a href="#SELCTLTool">SELCTLTool()</a>
<li><a href="#SetCNCexportActualFlutes">SetCNCexportActualFlutes()</a>
<li><a href="#SetCNCexportComments">SetCNCexportComments()</a>
<li><a href="#SetCNCexportExecDisabled">SetCNCexportExecDisabled()</a>
<li><a href="#SetCNCexportExecEnabled">SetCNCexportExecEnabled()</a>
<li><a href="#SetCNCexportExecSpeedprofileActive">SetCNCexportExecSpeedprofileActive()</a>
<li><a href="#SetCNCexportInsertStopAfterWorkingstep">SetCNCexportInsertStopAfterWorkingstep()</a>
<li><a href="#SetCNCexportMatrixOff">SetCNCexportMatrixOn/Off()</a>
<li><a href="#SetCNCexportNumberOfDigits">SetCNCexportNumberOfDigits()</a>
<li><a href="#SetCNCexportProgramNum">SetCNCexportProgramNum()</a>
<li><a href="#SetCNCexportSpeedOverride">SetCNCexportSpeedOverride()</a>
<li><a href="#SetCNCexportToolOpts">SetCNCexportToolOpts()</a>
<li><a href="#SetCNCexportTraceability">SetCNCexportTraceability()</a>
<li><a href="#SetCNCexportUnits">SetCNCexportUnits()</a>
<li><a href="#SetCNCexportUsingBlocknumbers">SetCNCexportUsingBlocknumbers()</a>
<li><a href="#SetCNCexportUsingTCP">SetCNCexportUsingTCP()</a>
<li><a href="#SetCNCexportWorkoffset">SetCNCexportWorkoffset()</a>
<li><a href="#SetDebuggingNamesOff">SetDebuggingNamesOn/Off()</a>
<li><a href="#SetDefineArcUsingViaOff">SetDefineArcUsingViaOn/Off()</a>
<li><a href="#SetDirection">SetDirection()</a>
<li><a href="#SetLocation">SetLocation()</a>
<li><a href="#SetMaximumDeviation">SetMaximumDeviation()</a>
<li><a href="#SetModeMill">SetModeMill()</a>
<li><a href="#SetModeTurn">SetModeTurn()</a>
<li><a href="#SetName">SetName()</a>
<li><a href="#SetNameCheckSTRL">SetNameCheckSTRL()</a>
<li><a href="#SetNameCreateSTRL">SetNameCreateSTRL()</a>
<li><a href="#SetNameGet">SetNameGet()</a>
<li><a href="#SetNameGetSTRL">SetNameGetSTRL()</a>
<li><a href="#SetNameHasSTRL">SetNameHasSTRL()</a>
<li><a href="#SetNameHitSTRL">SetNameHitSTRL()</a>
<li><a href="#SetNameSTRL">SetNameSTRL()</a>
<li><a href="#SetNameType">SetNameType()</a>
<li><a href="#SetToolAutoNumberOff">SetToolAutoNumberOn/Off()</a>
<li><a href="#SetToolIdentifier">SetToolIdentifier()</a>
<li><a href="#SetToolNumber">SetToolNumber()</a>
<li><a href="#SetUUID">SetUUID_force()/_if_not_set()/to_string()</a>
<li><a href="#Shutdown">Shutdown()</a>
<li><a href="#SpindleSpeed">SpindleSpeed()</a>
<li><a href="#SpindleSpeedUnit">SpindleSpeedUnit()</a>
<li><a href="#Stop">Stop()</a>
<li><a href="#StopAfter">StopAfter()</a>
<li><a href="#STRLCapture">STRLCapture()</a>
<li><a href="#STRLRestore">STRLRestore()</a>
<li><a href="#ToolGeometry">ToolGeometry()</a>
<li><a href="#URLGet">URLGet()</a>
<li><a href="#URLHas">URLHas()</a>
<li><a href="#URLSet">URLSet()</a>
<li><a href="#UsingEnglishUnits">UsingEnglishUnits()</a>
<li><a href="#UsingFrenchUnits">UsingFrenchUnits()</a>
<li><a href="#Workingstep">Workingstep()</a>
<li><a href="#WorkingstepAfter">WorkingstepAfter()</a>
<li><a href="#WorkingstepOperationReuse">WorkingstepOperationReuse()</a>
<li><a href="#WorkingstepOperationReuseAfter">WorkingstepOperationReuseAfter()</a>
<li><a href="#WorkingstepReuse">WorkingstepReuse()</a>
<li><a href="#WorkingstepReuseAfter">WorkingstepReuseAfter()</a>
<li><a href="#WorkingstepToolpathOrientation">WorkingstepToolpathOrientation()</a>
<li><a href="#WorkingstepToolpathOrientationDelete">WorkingstepToolpathOrientationDelete()</a>
<li><a href="#WorkingstepToolpathOrientationReuse">WorkingstepToolpathOrientationReuse()</a>
<li><a href="#Workpiece">Workpiece()</a>
<li><a href="#WorkpieceAndRawpiece">WorkpieceAndRawpiece()</a>
<li><a href="#WorkpieceSecondPlacement">WorkpieceSecondPlacement()</a>
<li><a href="#WorkplanFromSelective">WorkplanFromSelective()</a>
<li><a href="#WorkplanSetup">WorkplanSetup()</a>
<li><a href="#WorkplanSetupDelete">WorkplanSetupDelete()</a>
<li><a href="#WorkplanSetupFixture">WorkplanSetupFixture()</a>
<li><a href="#WorkplanSetupFixtureMountGet">WorkplanSetupFixtureMountGet/Put()</a>
<li><a href="#WorkplanSetupFixtureWorkpieceGet">WorkplanSetupFixtureWorkpieceGet/Put()</a>
<li><a href="#WorkplanSetupGet">WorkplanSetupGet/Put()</a>
<li><a href="#WorkplanToSelective">WorkplanToSelective()</a>
</ul>
</div>

<div class=main>

<!-- ================================ -->
<h2><a name=oview></a>Overview</h2>
<p>
The <b>AptStepMaker</b> class creates AP-238 files from APT-like tool
movement data. APT is a legacy language from the 1950&rsquo;s that
defines tool path geometries. In the beginning it was used in a
similar way to FORTRAN except it created machine tool programs rather
than computer programs. In recent years CAM systems have replaced APT
systems but many CAM systems still write APT data so it is the most
widely available common denominator for tool path information.

<P>APT is the most important but not the only source of data for the
STEP-NC API. There are functions to read several flavors of RS274D/ISO
6983 files, for example, see
the <a href="#ImportHaas">ImportHass</a>, <a href="#ImportHaas">ImportSiemens</a>
and <a href="#ImportFanuc">ImportFanuc</a> functions, and there are
functions to read STEP files to define the geometries and tolerances
of the workpiece, stock, fixtures and cutting tools, for example see
the <a href="#Workpiece">Workpiece</a>
and <a href="#Rawpiece">Rawpiece</a> functions.

<P>The legacy APT programming language is state driven. Each time a
new tool path is created the current feed, speed and other quantities
are added to that tool path as necessary. The APT object has been
written for APT parsers so it is also state driven. Hence, at any time
there is a current workpiece, workplan, workingstep, feed, speed and
so on (see the <a href="#GetCurrentWorkpiece">GetCurrent</a>
functions).

<P>STEP-NC is NOT state driven. The APT object takes the state driven
commands of APT and converts them into a graph of STEP-NC objects
where every quality of every object is explicitly attached to that
object. Only the APT object has a state model in the STEP-NC API. The
other objects use navigation models in which a given argument is used
as the starting point to find other objects. It can be argued that
another version of the APT object should be written for more modern
applications that is not state driven. The process object contains
some of the required functionality.
</p>


<!-- ======================================== -->
<h2 class="rule"><a name=ids></a>A Note on Identifiers</h2>

<p>Every entity in a STEP file has an identifier. The Part 21 format
requires this entity to be a number, and the XML (Part 28) format uses
the same rule in order to maintain compatibilty. Many functions in the
API return these numbers and many other functions require them to be
supplied as arguments. This is especially the case for the functions
in
the <A href="Feature.html">Feature</A>, <A href="Process.html">Process</A>
and <A href="Tolerance.html">Tolerance</A> object that build various
kinds of data.

<P>The identifier used for an entity instance is only persistent until
the data is saved to a file. An application CANNOT store the
identifier somewhere and use it to find the entity when the file is
read into memory again. If an application needs this functionality
then you should check to see if the object has another relevanat
attribute. For example, many of the STEP-NC objects have an its_id
attribute that can be used as an identifier.

<P>Universally Unique IDentifiers (UUID's) are a new solution for
persistent identity that has been added to the latest edition of
the Part 21 format. New functions have been added to the APT
object to set these identifiers. See the <A href="#SetUUID">SetUUID...()</A>
functions for more details. 



<!-- ================================ -->
<h2 class=rule>
<a name=ArcABC></a>ArcABC()</h2>
<pre>
void <b>ArcABC</b> (
	System::String^ label,
	double new_x,
	double new_y,
	double new_z,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>ArcABC()</b> function defines a curve with a contact normal. The curve is in the plane
defined by the current axis.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>new_x, new_y, new_z: <DD> (x, y, z) components for the end of the arc.
<DT>cx, cy, cz: <DD> (i, j, k) components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
<DT>a, b, c: <DD> (a, b, c) components for the contact normal at the end of the arc.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Arc">ArcXYPlane(), ArcYZPlane(), ArcZXPlane()</a>: For a detailed description of how to make arcs.
<li><a href="#SetDirection">SetDirection</a>: This function sets the current axis.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ArcGeneralPlane></a>ArcGeneralPlane()</h2>
<pre>
void <b>ArcGeneralPlane</b> (
	System::String^ label,
	double new_x,
	double new_y,
	double new_z,
	double cx,
	double cy,
	double cz,
	double ci,
	double cj,
	double ck,
	double ca,
	double cb,
	double cc,
	double radius,
	System::Boolean ccw
	);
</pre>

<P>The <b>ArcGeneralPlane()</b> function defines an arc in a given
plane. All the other arguments are the same as for the arc function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>new_x, new_y, new_z: <DD> (X, y, z) components for the normal of the plane.
<DT>ci, cj, ck: <DD> (i, j, k) components for the normal of the plane.
<DT>ca, cb, cc: <DD> (a, b, c) components for the reference direction
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.</DL>



<!-- ================================ -->
<h2 class=rule>
<a name=ArcRefABC></a>ArcRefABC()</h2>
<pre>
void <b>ArcRefABC</b> (
	System::String^ label,
	double x,
	double y,
	double z,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Int64 ccw,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>ArcRefABC()</b> function defines an arc for a non-spinning tool. The a, b and c components define
the reference direction for this non-spinning tool at the end of the arc.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>new_x, new_y, new_z: <DD> (i, j, k) components for the end of the arc.
<DT>cx, cy, cz: <DD> (i, j, k) components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
<DT>a, b, c: <DD> (a, b, c) components for the tool refernce direction at the end of the arc.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GoToXYZ_IJK_REF_ABC">GoToXYZ_IJK_REF_ABC</a>: This function adds line segments
with a tool reference direction to the geometry.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=Arc></a>ArcXYPlane(), ArcYZPlane(), ArcZXPlane()</h2>

<pre>
void <b>ArcXYPlane</b> (
	System::String^ label,
	double new_x,
	double new_y,
	double new_z,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);

void <b>ArcYZPlane</b> (
	System::String^ label,
	double new_x,
	double new_y,
	double new_z,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);

void <b>ArcZXPlane</b> (
	System::String^ label,
	double new_x,
	double new_y,
	double new_z,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);
</pre>


<P>The <b>ArcZXPlane()</b>, <b>ArcXYPlane()</b>
and <b>ArcYZPlane()</b> functions add an arc to the current tool
path. The tool path is assumed to have a start point defined by the
last geometry item added to the path. The arc command moves the
cutting tool tip to a new point that then becomes the current point
for the next geometry command.

<P>If the current workplan does not contain any workingsteps then one
will be created implicitly. If the workingstep does not contain any
tool paths then one will be created implicitly and the new arc wil
become the first item in that tool path.

<P>If the arc is the first item in a new tool path after a tool change
then the point defined using
the <a href="#FirstPathStartPoint">FirstPathStartPoint</a> function
will be used as the start point for the arc. If no such point has been
defined then there will be an error.

<P>If this is the first point in a new tool path but there was not a
tool change then the last point defined in the last tool path will be
used as the start point.

<P>If no feedrate has been defined then the feedrate will be zero. If
no spindle speed has been defined then the spindle speed will be zero.
If no tool has been loaded then the tool number will be zero.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD>A string argument that defines a name for the geometry
item. Typically this will be the empty string but it can be any
identifier.
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the arc.
<DT>cx, cy, cz: <DD>The x, y, z coordinates of the center of the
circle that defines the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.

<p>The above arguments are partially redundant, for example, the
requirement to give a z coordinate for the circle center is redundant
if this arc is in the XY plane.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ArcGeneralPlane">ArcGeneralPlane</a>: Make an Arc in any
plane
<li><a href="#GoToXYZ">GoToXYZ</a>: This function adds line segments
to the geometry.
<li><a href="#FirstPathStartPoint">FirstPathStartPoint</a>: This
function defines a start point for the arc if the new arc is the first
segment in the first tool path after a tool change.
<li><a href="#SetDirection">SetDirection</a>:  This function defines a
plane for the arc. The default is the XY plane.
<li><a href="#Feedrate">Feedrate</a>:  This function sets the
current feedrate.
<li><a href="#SpindleSpeed">SpindleSpeed</a>:  This function sets the
current spindle speed.
<li><a href="#LoadTool">LoadTool</a>:  This function sets the current
cutting tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>In Rapid mode: Most CNC systems will not allow rapid arc moves so
this is assumed to mean there is an error in the input data.
<li>No first point: This is the first move in the first tool path
after a tool change and no starting point has been defined
using <a href="#FirstPathStartPoint">FirstPathStartPoint</a>.

<li>The arc function does not check for the semantic error of defining
an arc whose radius is too large for the given start, end and center
points.

<li>The arc function does not check to make sure the start, end and
center points are in the plane previously defined by the SetDirection
function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=CamModeOff></a>
<a name=CamModeOn></a>CamModeOn/Off()</h2>

<pre>
void <b>CamModeOn</b> ();
void <b>CamModeOff</b> ();
</pre>

<P>The <b>CamModeOn()</b> and <b>CamModeOff()</b> functions control
how the API separates moves into workingsteps.  By default, CAM mode
is Off and the API creates a new workingstep whenever the spindle
speed changes.  This default should normally used by APT parsers
because otherwise the workingsteps made by the parsers will be very
long and difficult to manage.

<P>When CAM mode is On, your applicaton must create new workingsteps
explicitly by changing the tool or calling
the <a href="#Workingstep">Workingstep</a> function.


<h3>Related Functions</h3>

<UL>
<li><a href="#SpindleSpeed">SpindleSpeed</a>: If Cam mode is on then a
change to the spindle speed will create a new tool path but not a new
workingstep. If Cam mode is off then a change will only create a new
tool path.
<li><a href="#LoadTool">LoadTool</a>: A new workingstep is created
whenever the tool is changed.
<li><a href="#Feedrate">Feedrate</a>: A new toolpath is created
wheneve the feedrate is changed.
<li><a href="#Workingstep">Workingstep</a>: CAM translators can use
this function to explicitly create new workingsteps and thereby make
sure that each CAM operation corresponds to one workingstep even if
the spindle speed changes.
</UL>







<!-- ================================ -->
<h2 class=rule>
<a name=CenterOn></a>CenterOn()</h2>
<pre>
void <b>CenterOn</b> ();
</pre>

<P>After the <b>CenterOn()</b> function is called, all subsequent
toolpaths will be in Cutter Center mode. In this mode the tool path
describes the center line of the cutting tool tip. The other mode is
Cutter Contact mode &ndash; see
the <a href="#ContactOn">ContactOn</a>,
<a href="#Left">Left</a> and <a href="#Right">Right</a> functions.

<P>If the API is in the middle of creating a tool path and if that
tool path is not in Cutter Center mode then the current tool path is
ended and the next geometry item is added to a new cutter center tool
path.

<h3>Related Functions</h3>
<UL>
<li><a href="#Arc">Arc</a>:  This function ads arc segments
to the geometry.
<li><a href="#GoToXYZ">GoToXYZ</a>: This function adds line segments
to the geometry.
<li><a href="#ContactOn">ContactOn</a>: This function puts the system
into cutter contact mode.
<li><a href="#Left">Left</a>: This function puts the system into
cutter contact mode with the contact point on the left hand side of
the tool.
<li><a href="#Right">Right</a>: This function puts the system into
cutter contact mode with the contact point on the right hand side of
the tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>





<!-- ================================ -->
<h2 class=rule>
<a name=ChangeWorkingstepTool></a>ChangeWorkingstepTool()</h2>
<pre>
void <b>ChangeWorkingstepTool</b> (
	System::Int64 ws_id,
	System::Int64 tl_id
	);
</pre>

<P>The <b>ChangeWorkingstepTool()</b> function changes the workingstep
of a tool. The two tools should be compatible. The function checks to
make sure they have the same diameter. Theis can be used to clean up a
project after another workplan has been inserted into that project. If
the inserted workplan uses the same tools as workingsteps already in
the project then those tools can be assigned to the inserted
workingsteps.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id: <DD>The identity of the workingstep.
<DT>tl_id: <DD> The identity of the new tool.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ImportWorkplanFromFile">ImportWorkplanFromFile</a>:
Import the operations and tooling in another file into the current
file.
<li><a href="#DeleteToolParameters">DeleteToolParameters</a>: Delete
the parameters of a tool that is no longer being used after all its
operations have been assigned to another tool.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=CircleGeneralPlane></a>CircleGeneralPlane()</h2>
<pre>
void <b>CircleGeneralPlane</b> (
	System::String^ label,
	double cx,
	double cy,
	double cz,
	double ci,
	double cj,
	double ck,
	double ca,
	double cb,
	double cc,
	double radius,
	System::Boolean ccw
	);
</pre>

<P>The <b>CircleGeneralPlane()</b> function defines a circle in any plane.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>cx, cy, cz: <DD> (x, y, z) components for the center of the arc.
<DT>ci, cj, ck: <DD> (i, j, k) axis direction components for the center of the arc.
<DT>ca, cb, cc: <DD> (a, b, c) reference direction components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
</DL>

<!-- ================================ -->
<h2 class=rule>
<a name=CircleXYPlane></a>CircleXYPlane()</h2>
<pre>
void <b>CircleXYPlane</b> (
	System::String^ label,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);
</pre>

<P>The <b>CircleXYPlane()</b> function defines a circle in the XY plane.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>cx, cy, cz: <DD> (x, y, z) components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
</DL>
<!-- ================================ -->
<h2 class=rule>
<a name=CircleYZPlane></a>CircleYZPlane()</h2>
<pre>
void <b>CircleYZPlane</b> (
	System::String^ label,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);
</pre>

<P>The <b>CircleYZPlane()</b> function defines a circle in the YZ plane.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>cx, cy, cz: <DD> (x, y, z) components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
</DL>

<!-- ================================ -->
<h2 class=rule>
<a name=CircleZXPlane></a>CircleZXPlane()</h2>
<pre>
void <b>CircleZXPlane</b> (
	System::String^ label,
	double cx,
	double cy,
	double cz,
	double radius,
	System::Boolean ccw
	);
</pre>

<P>The <b>CircleZXPlane()</b> function defines a circle in the ZX plane.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>cx, cy, cz: <DD> (x, y, z) components for the center of the arc.
<DT>radius: <DD>The radius of the circle.
<DT>ccw: <DD>If non-zero then the arc will travel from the current
point to the new end point in a counter clockwise direction.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=Clean></a>Clean()</h2>
<pre>
void <b>Clean</b> ();
</pre>

<P>The <b>Clean()</b> function removes any data in the workspace that
is not connected to the current project.  If the application is short
of memory space then the clean function may be able to find enough
space to allow for completion of the program. If an application loses
data because an object is not attached to the project then the clean
function may be able to help reveal when this is happening.

<h3>Related Functions</h3>
<UL>
<li><a href="#Reset">Reset</a>: This function sets the APT object back
to its initial state.
<li><a href="#Shutdown">Shutdown</a>:  This function deletes all the
memory used by the APT object.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ClearancePlane></a>ClearancePlane()</h2>
<pre>
void <b>ClearancePlane</b> (
	double z_coordinate
	);
</pre>

<P>The <b>ClearancePlane()</b> function defines a safety plane for
rapid movements. If an application is generating its own tool paths
then it can use the clearance plane to move the tool between
operations.

<P>In the STEP-NC standard the clearance plane is called the "Security
Plane" and it can be any arbitrary plane. In the API the Clearance
plane has to be an XY plane and the clearance is defined by a positive
Z value.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>z: <DD> The clearance is defined to be an XY plane at Z distance
from the origin. All subsequent workingstep will be given this
clearance plane until it is reset. If the z value is zero or negative
then the clearance plane is set to NULL for subsequent
workingsteps.

<p>A more powerful security plane function needs to be written that
allows the security plane to be any plane.
</DL>


<h3>Related Functions</h3>
<UL>

<li><a href="#Retract">Retract</a>: This function defines the retract
plane for an operation. This plane is also a safe plane but unlike the
security plane it is only safe for the selected operation.

<li>The functions in the Process object that create the different
types of milling, drilling and turning objects use the clearance
plane.
</UL>



<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>The API does not contain functionality to check for rapid tool
movements below the security plane.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=CompressTechnology></a>CompressTechnology()</h2>
<pre>
System::Int64 <b>CompressTechnology</b> ();
</pre>

<P>The <b>CompressTechnology()</b> function removes duplicate
technology descriptions. A technology is a feed, speed pair. If two
technologies have the same feeds and speeds then the second one will
be eliminated.

<h3>Result</h3>
<UL>
<li>The function returns a count of the remaining technologies.
</UL>


<h3>Related Functions</h3>
<UL>
<li><a href="#Feedrate">Feedrate</a>: This function sets the feedrate
for any new toolpaths.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: This function sets the
spindle speed for any new toolpaths.
</UL>

<h3>Common Errors</h3>
<UL>

<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.

<li> Eliminating duplicate technologies is not a good idea if two
paths use the same feed and speed by accident. In this case if the
technology has been compressed and the feed or speed of one path is
modified then the modification will also apply to the other path. <p>
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Connector></a>Connector()</h2>
<pre>
void <b>Connector</b> ();
</pre>

<P>The <b>Connector()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ContactOn></a>ContactOn()</h2>
<pre>
void <b>ContactOn</b> ();
</pre>

<P>The <b>ContactOn()</b> function creates all subsequent toolpaths
will be in Cutter Contact mode. Cutter contact mode enables three and
five axis tool diameter wear compensation. In this mode the tool path
describes the normal of the point of contact between the cutting tool
and workpiece. If the part is being made using three axis milling then
the contact point between the cutting tool and workpiece can be
described using the <a href="#Left">Left</a>
and <a href="#Right">Right</a> functions. If five axis milling is
being used then the point must be defined using versions of
the <a href="#ArcABC">Arc</a> and <a href="#GoToXYZ_IJK_ABC">GoTo</a>
functions that include a, b and c parameters.

<P>If the API is in the middle of creating a tool path and if
that tool path is not in Cutter Contact mode then the tool path is ended and
the next geometry item will start a new cutter contact  tool path.


<h3>Related Functions</h3>
<UL>
<li><a href="#ArcABC">ArcABC</a>: This function defines arc segments
with a contact normal.
<li><a href="#GoToXYZ_ABC">GoToXYZ_ABC</a>: This function defines line
segments with a contact normal.
<li><a href="#GoToXYZ_IJK_ABC">GoToXYZ_IJK_ABC</a>: This function also
defines line segments with an axis vector and a contact normal.
<li><a href="#CenterOn">CenterOn</a>: This function puts the system
into cutter center mode.
<li><a href="#Left">Left</a>: This function puts the system into
cutter contact mode with the contact normal on the left hand side of
the tool. The API will calculate ABC vectors for the left hand side.
<li><a href="#Right">Right</a>: This function puts the system into
cutter contact mode with the contact normal on the right hand side of
the tool. The API will calculate ABC vectors for the right hand side.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>




<!-- ================================ -->
<a name=CoolantOff></a>
<a name=CoolantMist></a>
<a name=CoolantThru></a>
<h2 class=rule>
<a name=CoolantOn></a>CoolantOn/Off/Mist/Thru()</h2>
<pre>
void <b>CoolantOn</b> ();
void <b>CoolantOff</b> ();
void <b>CoolantMist</b> ();
</pre>

<P>The coolant functions control the coolant state for subsequent tool
paths.  <b>CoolantOn()</b> turns the coolant on and makes it of type
flood.  <b>CoolantMist()</b> function turns coolant on and makes it
mist coolant instead of flood. <b>CoolantThru()</b> function turns
coolant on and makes it through-spindle coolant instead of
flood.  <b>CoolantOff()</b> stops coolant, regardless of type.

<P>If the coolant is not currently on, or not of type mist then a new
tool path is started.  Through spindle coolant is not yet implemented
by the API.


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>




<!-- ================================ -->
<h2 class=rule>
<a name=CutterDiameterCompensationAssignment></a>CutterDiameterCompensationAssignment()</h2>
<pre>
void <b>CutterDiameterCompensationAssignment</b> (
	double value
	);
</pre>

<P>The <b>CutterDiameterCompensationAssignment()</b> function sets a
value in the cutter compensation register to compensate for tool
wear. To operate effectively this function requires deep integration
between the STEP-NC API and the underlying CNC control.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>value: <DD>The tool wear compensation value.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ContactOn">ContactOn</a>: This function creates tool
paths that should use the CutterDiameterCompensationAssignment value
to calculate the tool wear compensation &ndash; see
also <a href="#Left">Left</a> and <a href="#Right">Right</a>.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li> The tolerance object contains functions to measure tool wear.
</UL>

<!-- ================================ -->
<a name=DefaultToMillimeters></a>
<h2 class=rule>
<a name=DefaultToInches></a>DefaultToInches() / DefaultToMillimeters()</h2>
<pre>
void <b>DefaultToInches</b> ();
void <b>DefaultToMillimeters</b> ();
</pre>

<P>Some APT tool path programs do not define their units for distance
measurements.  <P>The <b>DefaultToInches()</b> function tells the
system to use a default of inches and
the <b>DefaultToMillimeters()</b> function tells the
system to use a default of millimeters.

<P>The ratio of inches to millimeters is 1:25.4 so there is a
considerable difference in size if the wrong units are applied to a
file. If items cannot be seen in the visualization then this may be
the reason and you should try again with different default units.


<h3>Related Functions</h3>
<UL>
<li><a href="#Inches">Inches</a>: This function sets the length unit
to inch for all subsequently defined geometry.
<li><a href="#Millimeters">Millimeters</a>: This function sets the
length unit to millimeter for all subsequently defined geometry.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=DefineTool></a>DefineTool()</h2>
<pre>
void <b>DefineTool</b> (
	double tool_diameter,
	double tool_radius,
	double horizontal_distance,
	double vertical_distance,
	double unused,
	double angle,
	double height
	);
</pre>

<P>The <b>DefineTool()</b> function defines the parameters of a
cutting tool.  There are a large number of parameters. For a full
definition see an APT reference manul. In practice the parameters
defined in most programs are, in order of popularity, the cutting tool
diameter, the cutting tool radius, the cutting tool length, and the
cutting tool taper angle.

<P>The cutting tool diameter is different to the cutting tool radius
and a frequent cause of confusion to new CNC users. The diameter
describes the diameter of the tool, but the radius describes the
radius of a fillet between the diameter and the length of the
cylinder.

<P>In APT programs a tool is identified by a tool number that
corresponds to the placement position of the tool in a tool
holder. The <a href="#SELCTLTool">SELCTLTool</a>
and <a href="#LoadTool">LoadTool</a> functions in the API allow tools
to be selected and loaded using these numbers.


<P>The DefineTool function is only recommended for APT
programs. Modern CAM systems use more specific types of tools and
these are available as separate functions.

<h3>Arguments</h3>
<DL class=termdefs>

<DT>tool_diameter: <DD>The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.

<DT>tool_radius: <DD> The radius of the fillet at the bottom of the
tool. Called Corner_radius in the STEP-NC standard.

<DT>horizontal_distance: <DD>Called Corner_radius_horizontal in the
STEP-NC standard.

<DT>horizontal_vertical: <DD>Called Corner_radius_vertical in the STEP-NC
standard.

<DT>unused: <DD> As per the name this field is not often used in APT
programs. Called tip_outer_angle in the STEP-NC standard.

<DT>angle: <DD>Called Taper_angle in the STEP-NC standard.

<DT>height: <DD>The length of the tool. Called Overall_assembly_length
in the STEP-NC standard.

</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool2">DefineTool2</a>: Defines a tool with all
the above parameters plus an identifier that can be used to search for
the tool in libraries.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#SetToolAutoNumberOn">SetAutoToolNumberOn</a>: Some APT
programs do not define a tool number. This function allows API
application to control whether or not these tools should be given a
number automatically.
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
AP-203 geometry of a tool.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolCoolantThrough></a>DefineToolCoolantThrough()</h2>
<pre>
void <b>DefineToolCoolantThrough</b> (
	System::Int64 on_off
	);
</pre>

<P>The <b>DefineToolCoolantThrough()</b> function sets the coolant
flag for the current tool to on or off. The tool must be a milling
cutting tool which means it cannot be an APT tool.

<h3>Arguments</h3>
<DL class=termdefs>

<DT>on_off: <DD> If non-zero then the through coolant attribute of the
tool is set to on.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineToolDrill">DefineToolDrill</a>: Create a milling
cutting tool.
<li><a href="#DefineToolEndMill">DefineToolEndMill</a>: Create a
milling cutting tool.
<li><a href="#DefineToolFaceMill">DefineToolFaceMill</a>: Create a
milling cutting tool.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolDrill></a>DefineToolDrill()</h2>
<pre>
void <b>DefineToolDrill</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut,
	double point_angle
	);
</pre>

<P>The <b>DefineToolDrill()</b> function defines the parameters of a
drilling tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD>The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD>The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD>The maximum allowed depth of cut for this
tool.
<DT>point_angle: <DD>The angle at the tip of the drill.
</DL>



<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>: Defines a tool with the APT
parameters.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
geometry of a tool.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolEndmill></a>DefineToolEndmill()</h2>
<pre>
void <b>DefineToolEndmill</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut,
	double num_effective_teeth,
	double cutting_edge_angle
	);
</pre>

<P>The <b>DefineToolEndmill()</b> function defines the parameters of
an endmill. An end mill is used for milling pockets and other
features.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD>The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
<DT>num_effective_teeth: <DD> The number of flutes on the tool.
<DT>cutting_edge_angle: <DD> The angle at the edge of the tool.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>: Defines a tool with the APT
parameters.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
geometry of a tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</li>
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolFacemill></a>DefineToolFacemill()</h2>
<pre>
void <b>DefineToolFacemill</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut,
	double num_effective_teeth,
	double cutting_edge_angle
	);
</pre>

<P>The <b>DefineToolFacemill()</b> function defines the parameters of
an facemill. A face mill is used for milling faces.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD> The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length:  <DD> The total length of the tool
&ndash; used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
<DT>num_effective_teeth: <DD> The number of flutes on the tool.
<DT>cutting_edge_angle: <DD> The angle at the edge of the tool.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>:   Defines a tool with
the APT parameters.
<li><a href="#SELCTLTool">SELCTLTool</a>:   Defines a tool number
for the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>:   Starts a new
workingstep using the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>:   A function to define
the geometry of a tool.
</UL>


<h3>Common Errors</h3>
<UL>

<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolFeedAndSpeed></a>DefineToolFeedAndSpeed()</h2>
<pre>
void <b>DefineToolFeedAndSpeed</b> (
	double tool_feedrate,
	double tool_spindle_speed
	);
</pre>

<P>The <b>DefineToolFeedAndSpeed()</b> function sets a default feed
and speed for the current tool. The tool must be a milling cutting
tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>feedrate: <DD> The default federate for the tool in the current
feederate units.
<DT>spindle_speed: <DD> The default spindle speed for the tool in the
current rotation units.
</DL>


<h3>Related Functions</h3>
<UL>

<li><a href="#DefineToolDrill">DefineToolDrill</a>: Function to create
a milling cutting tool.
<li><a href="#DefineToolEndMill">DefineToolEndMill</a>: Function to
create a milling cutting tool.
<li><a href="#DefineToolFaceMill">DefineToolFaceMill</a>: Function to
create a milling cutting tool.
<li><a href="#FeedrateUnit">FeedrateUnit</a>: Function to set the
current federate unit.
<li><a href="#SpindleSpeedUnit">SpindleSpeedUnit</a>: Function to set
the current spindle speed unit.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolHandOfCut></a>DefineToolHandOfCut()</h2>
<pre>
void <b>DefineToolHandOfCut</b> (
	System::String^ left_right_or_neutral
	);
</pre>

<P>The <b>DefineToolHandOfCut()</b> function sets the hand of cut for
the current tool.  The tool must be a milling cutting tool.

<h3>Arguments</h3>
<DL class=termdefs>

<DT>left_right_or_neutral: <DD> The value &ldquo;left&rdquo;,
&ldquo;right&rdquo; or &ldquo;neutral&rdquo;.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineToolDrill">DefineToolDrill</a>: Function to create
a milling cutting tool.
<li><a href="#DefineToolEndMill">DefineToolEndMill</a>: Function to
create a milling cutting tool.
<li><a href="#DefineToolFaceMill">DefineToolFaceMill</a>: Function to
create a milling cutting tool.<p>
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolMaterial></a>DefineToolMaterial()</h2>
<pre>
void <b>DefineToolMaterial</b> (
	System::String^ standard_identifier,
	System::String^ material_identifier
	);
</pre>

<P>The <b>DefineToolMaterial()</b> function sets the material for the
current tool. The tool must be a milling cutting tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>standard: <DD> Reference standard that defines the material.
<DT>material: <DD> Name of the material in the standard.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineToolDrill">DefineToolDrill</a>: Function to create
a milling cutting tool.
<li><a href="#DefineToolEndMill">DefineToolEndMill</a>: Function to
create a milling cutting tool.
<li><a href="#DefineToolFaceMill">DefineToolFaceMill</a>: Function to
create a milling cutting tool.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolRadius></a>DefineToolRadius()</h2>
<pre>
void <b>DefineToolRadius</b> (
	double radius
	);
</pre>

<P>The <b>DefineToolRadius()</b> function sets the edge_radius for the
current tool.  The tool must be a milling cutting tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>radius: <DD> The edge radius for the tool.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineToolDrill">DefineToolDrill</a>: Function to create
a milling cutting tool.
<li><a href="#DefineToolEndMill">DefineToolEndMill</a>: Function to
create a milling cutting tool.
<li><a href="#DefineToolFaceMill">DefineToolFaceMill</a>: Function to
create a milling cutting tool.<p>
</UL>

<h3>Common Errors</h3>
<UL>
<li>New users should not confuse the edge_radius with the
diameter. The edge radius defines a chamfer on the edge of the tool.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolRotatingBoringCuttingTool></a>DefineToolRotatingBoringCuttingTool()</h2>
<pre>
void <b>DefineToolRotatingBoringCuttingTool</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut
	);
</pre>

<P>The <b>DefineToolRotatingBoringCuttingTool()</b> function defines
the parameters of an rotating, boring cutting tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD> The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
</DL>



<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>:   Defines a tool with
the APT parameters.
<li><a href="#SELCTLTool">SELCTLTool</a>:   Defines a tool number
for the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>:   Starts a new
workingstep using the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>:   A function to define
the geometry of a tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolSpotDrill></a>DefineToolSpotDrill()</h2>
<pre>
void <b>DefineToolSpotDrill</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut,
	double point_angle
	);
</pre>

<P>The <b>DefineToolSpotDrill()</b> function defines the parameters of
a spot drilling tool. When necessary a spot drill is used to start a
drilling hole so that a subsequent drill can complete that hole.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD> The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
<DT>point_angle: <DD> The angle at the tip of the drill.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineDrillTool</a>: Defines an ordinary
drill tool.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
geometry of a tool.
</UL>

<h3>Common Errors</h3>
<UL>
 <li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolStraightReamer></a>DefineToolStraightReamer()</h2>
<pre>
void <b>DefineToolStraightReamer</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut
	);
</pre>

<P>The <b>DefineToolStraightReamer()</b> function defines the
parameters of a straight reamer tool (no taper).

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD> The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineDrillTool</a>: Defines an ordinary
drill tool.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
geometry of a tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DefineToolTapping></a>DefineToolTapping()</h2>
<pre>
void <b>DefineToolTapping</b> (
	double diameter,
	double overall_assembly_length,
	double functional_length,
	double max_depth_of_cut,
	System::String^ thread_form_type,
	double pitch,
	double size
	);
</pre>

<P>The <b>DefineToolTapping()</b> function defines the parameters of a
tapping tool. A tapping tool is used to add a screw thread to a
drilled hole.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>diameter: <DD> The diameter of the cutting tool. Called
Effective_cutting_diameter in the STEP-NC standard.
<DT>overall_assembly_length: <DD> The total length of the tool &ndash;
used for collision detection.
<DT>functional_length: <DD> The functional length used for 5-axis
compensation calculations.
<DT>max_depth_of_cut: <DD> The maximum allowed depth of cut for this
tool.
<DT>thread_form_type: <DD> The form type described as a string.
<DT>pitch: <DD> The pitch of the thread.
<DT>size: <DD> The size of the thread.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineDrillTool</a>: Defines an ordinary
drill tool.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
<li><a href="#ToolGeometry">ToolGeometry</a>: A function to define the
geometry of a tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=DeleteAllUnusedTools></a>DeleteAllUnusedTools()</h2>
<pre>
void <b>DeleteAllUnusedTools</b> ();
</pre>

<P>The <b>DeleteAllUnusedTools()</b> function deletes any
tool definitions that are not currently used by a workingstep.




<!-- ================================ -->
<h2 class=rule>
<a name=DeleteAllUnusedWorkpieces></a>DeleteAllUnusedWorkpieces()</h2>
<pre>
void <b>DeleteAllUnusedWorkpieces</b> ();
</pre>

<P>The <b>DeleteAllUnusedWorkpieces()</b> function deletes any
workpiece that is not currently used to define the geometry of a
fixture, stock (as-is), final part (to-be) or cutting tool.

<h3>Related Functions</h3>
<UL>
<li><a href="#DeleteWorkpiece">DeleteWorkpiece</a>: Deletes a specific
workpiece.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=DeleteExecutable></a>DeleteExecutable()</h2>
<pre>
void <b>DeleteExecutable</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>DeleteExecutable()</b> function deletes the given
workingstep, nc function, workplan or selective from the STEP-NC
program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ex_id: <DD> The identity of the workinstep, workplan, nc function
or selective to be deleted.
</DL>


<h3>Related Functions</h3>
<UL>
<li>Any function that makes an executable.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ex_id does not identify an executable.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=DeleteFixture></a>DeleteFixture()</h2>
<pre>
void <b>DeleteFixture</b> (
	System::Int64 plan_id
	);
</pre>

<P>The <b>DeleteFixture()</b> function removes the fixture data from a
workplan. After the deletion the workplan will have no fixture data
or it will inherit its fixture data from its parent workplan.
After the deletion the fixture may be deleted if it is not used by
any other workplan.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan whose fixture reference is to be deleted.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="Finder.html#IsWorkplanWithSetupAndFixture">IsWorkplanWithSetupAndFixture</a>: Finder function that
returns true (1) if the workplan has a fixture defined.
<li><a href="#DeleteWorkpiece">DeleteWorkpiece</a>: Deletes a workpiece by removing
all its data from the project.
<li><a href="#Fixture">Fixture</a>: Define a fixture using a CAD file.
<li><a href="#ReuseFixtureReference">ReuseFixtureReference</a>: Explicitly define
a fixture for a workplan by reusing the data of another workplan. Useful if the
fixture cannot be inherited from a parent workplan.

</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DeleteToolParameters></a>DeleteToolParameters()</h2>
<pre>
void <b>DeleteToolParameters</b> (
	System::Int64 tl_id
	);
</pre>

<P>The <b>DeleteToolParameters()</b> function deletes a tool
description provided it is not being used by any workingstep.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tl_id: <DD> The identity of the tool to be deleted.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ChangeWorkingstepTool">ChangeWorkingstepTool</a>: Change
the tool of a workingstep (so that the tool can be deleted).
<li>There are many functions in the finder to find a tool.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=DeleteWorkpiece></a>DeleteWorkpiece()</h2>
<pre>
void <b>DeleteWorkpiece</b> (
	System::Int64 wp_id
	);
</pre>

<P>The <b>DeleteWorkpiece()</b> function deletes a specific
workpiece. The finder contains many functions that can be used to find
a workpiece. A workpiece may define geometry for an as-is, to-be or
delta model, fixture or tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD> The identity of the workpiece to be deleted.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Returns
the identity of the current workpiece or 0.
<li><a href="#Workpiece">Workpiece</a>: Define a workpiece using an
STEP CAD file.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=EditAddPoint></a>EditAddPoint()</h2>
<pre>
void <b>EditAddPoint</b> (	
	System::Int64 point_id,
	double x,
	double y,
	double z
);
</pre>

<P>The <b>EditAddPoint()</b> function adds a cartesian point to a polyline curve. If the curve is part of a toolpath
then the new point will be in that toolpath.

<p>The new toolpath must be valid after all the points have been added.
There are two issues to consider. The first is that if the
path is made up of many curves, for example a curve for the coordinates, a curve for the axis direction and a curve
for the contact normals, then points must be added to all those curves as well. The second is that when a path is
made up of a sequence of curves the end of the previous curve must be the start of the next. 

<P>Unfortunately these issues will not be detected until a system tries to render toolpaths again.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>point_id: <DD>The identity of a polyline curve.
<DT>x, y, z: <DD>Coordinate values for the added point.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="finder.html#GetPathCurveCount">GetPathCurvetNext</a>: This function
gets the identity of the next curve in a path.
<li><a href="#GoToXYZ">GoToXYZ</a>: This
function is much easier to use because it adds a point to the current path during the construction of a 
program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see the NewProject
function.
<li>Bad identity: The curve_id does not identify a cartesian point.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=EditChangePoint></a>EditChangePoint()</h2>
<pre>
void <b>EditChangePoint</b> (	
	System::Int64 point_id,
	double x,
	double y,
	double z
);
</pre>

<P>The <b>EditChangePoint()</b> function replaces the coordinates in a cartesian point with a new set of values. The point may represent
many kinds of data within the STEP-NC program. The most common case is for the point to represent a location on a tool path.
However, it could also be an axis direction (in which case the values should be normalized) or a model boundary. In the latter
case no checking will be made to make sure that the modified model is still valid.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>point_id: <DD>The identity of a cartesian point.
<DT>x, y, z: <DD>New coordinate values for the point.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="finder.html#GetPathPolylinePointNextID">GetPathPolylinePointNextID</a>: This function
gets the identity of a point in a path.
<li><a href="#GoToXYZ">GoToXYZ</a>: This
function adds a point to the currently open toolpath.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see the NewProject
function.
<li>Bad identity: The point_id does not identify a cartesian point.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=EmptyOperation></a>EmptyOperation()</h2>
<pre>
void <b>EmptyOperation</b> (
	);
</pre>
<P>The <b>EmptyOperaion()</b> function creates an empty operation for the current workingstep.
Normally APT tries to avoid creating a new operation until new data has been presented to the
interface. The EmptyOperation function forces any object that was previously being created to
be finished / closed. 

<P>After the operation has been created it can be filled with data using many functions in the APT
interface. This will be easier while the new operation continues to be the current operation.



<!-- ================================ -->
<h2 class=rule>
<a name=EndWorkplan></a>EndWorkplan()</h2>
<pre>
void <b>EndWorkplan</b> ();
</pre>

<P>The APT object puts all new process items into the current
workplan. When a new project is started a main_workplan is created and
it is made the current workplan. When a new workplan is created using
the <a href="#NestWorkplan">NestWorkplan</a> function it is added to
the current workplan, then the current workplan is saved onto a stack
and the new workplan becomes the current workplan.

<P>The <b>EndWorkplan()</b> function reverses this process by closing
the current workplan, poping the last nested workplan of the stack and
making it the current workplan.

<h3>Related Functions</h3>
<UL>
<li><a href="#NestWorkplan">NestWorkplan</a>: <DD> This function
starts a new workplan and places it in the current workplan.
<li><a href="#NestWorkplanAfter">NestWorkPlanAfter</a>: <DD> Gives
greater control over where the new workplan is placed in the STEP-NC
program.
<li><a href="#GetCurrentWorkplan">GetCurrentWorkplan</a>: <DD> This
function returns the internal identifier of the current workplan.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see the NewProject
function.
<li>Empty stack: If the stack is empty the system will assume you are
trying to end the main workplan which is not allowed.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=EstimateDepths></a>EstimateDepths()</h2>
<pre>
void <b>EstimateDepths</b> (
	System::Int64 wp_or_sh_id,
	[System::Runtime::InteropServices::Out] double %top,
	[System::Runtime::InteropServices::Out] double %bot,
	[System::Runtime::InteropServices::Out] double %front,
	[System::Runtime::InteropServices::Out] double %back,
	[System::Runtime::InteropServices::Out] double %left,
	[System::Runtime::InteropServices::Out] double %right,
	[System::Runtime::InteropServices::Out] System::Int64 %top_id,
	[System::Runtime::InteropServices::Out] System::Int64 %bot_id,
	[System::Runtime::InteropServices::Out] System::Int64 %front_id,
	[System::Runtime::InteropServices::Out] System::Int64 %back_id,
	[System::Runtime::InteropServices::Out] System::Int64 %left_id,
	[System::Runtime::InteropServices::Out] System::Int64 %right_id
	);
</pre>

<P>The <b>EstimateDepths()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableMoveAfter></a>ExecutableMoveAfter()</h2>
<pre>
void <b>ExecutableMoveAfter</b> (
	System::Int64 exe_id,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>ExecutableMoveAfter()</b> function places an executable into a workplan after a given
location function, and removes it from its old location

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD>The identity of the executable that is to be
placed in the workplan. The executable may be a workingstep, workplan, NC function
or selective.
<DT>index: <DD>The location where the executable is placed. The first location is zero, so an argument
value of "1" will make the the executable the second in the workplan. If the argument is less than zero then
the executable will be first. If the argument is greater than the current size then the executable will be
the last.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExecutableReuseAfter">ExectuableReuseAfter</a>: Move
the executable without deleting it from its old location.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The exe_id does not identify a workingstep, or the plan_id does not identify a workplan.
</UL>

</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableReuse></a>ExecutableReuse()</h2>
<pre>
void <b>ExecutableReuse</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>ExecutableReuse()</b> function repeats an executable by
putting it into the current workplan. For example, if the same
operation is needed in more than one alternative of a Selective.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD>The identity of the executable that is to be
repeated. The executable may be a workingstep, workplan, NC function
or selective.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ExecutableReuse">ExectuableReuseAfter</a>: This function
has parameters to control the placement of the repeated executable.
<li><a href="#WorkingstepReuse">WorkingstepReuse</a>: Repeats
workingsteps only.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The exe_id does not identify a workingstep.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableReuseAfter></a>ExecutableReuseAfter()</h2>
<pre>
void <b>ExecutableReuseAfter</b> (
	System::Int64 exe_id,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>ExecutableReuseAfter()</b> function repeats an executable at
a given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD> The identity of the executable that is to be
repeated. The executable may be a workingstep, workplan, NC function
or selective.
<DT>index: <DD> The desired position for the executable in the
workplan.
<DT>plan_id: <DD> The identity of the workplan that is to contain the
new executable.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ExecutableReuse">ExecutableReuse</a>: Repeats the
executable at the current end of the STEP-NC program.
<li><a href="#WorkingStepReuseAfter">WorkingstepReuseAfter</a>:
Repeats workingsteps only.
<li><a href="#ExecutableMoveAfter">ExecutableMoveAfter</a>:
Move executable and delete from old location.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The exe_id does not identify an executable.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableToSelective></a>ExecutableToSelective()</h2>
<pre>
System::Int64 <b>ExecutableToSelective</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>ExecutableToSelective()</b> function converts an executable
into a selective containing that executable. All workplans containing
that executable will now contain the new selective. If the executable
has before and after workpieces defined then they will be assigned to
the selective.

<P>The function prepares the data in a project for the definition of
alternate solutions. After the selective has been created new
workplans and other executable can be added to the selection and
definition for the workplans can be created by importing solutions
defined in other projects.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD>The identity of the executable that is to be replaced
by a selective containing the executable.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#NestWorkplanAfter">NestWorkplanAfter</a>:  Add a workplan
to the new selective so that it can be used to hold new solutions.
<li><a href="#ImportWorkplanFromFile">ImportWorkplanFromFile</a>:
Import the definitions in a workplan as an alternate solutions.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The exe_id does not identify an executable.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceAsIs></a>ExecutableWorkpieceAsIs()</h2>
<pre>
void <b>ExecutableWorkpieceAsIs</b> (
	System::Int64 ws_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ExecutableWorkpieceAsIs()</b> function defines the geometry
of a workingstep as-is volume from a STEP CAD file (AP203, AP214, or
AP242). The model describes what the geometry of the workpiece should
look like before the workingstep begins executing.

<P>The function assumes that all of the geometry in the file should be
 the as-is model. Any STEP file can be used, and if it is a newer file
 then tolerances and dimensions can be included on the model. See the
<a href="Tolerance.html">Tolerance</a> object for more information.


<P>The intent of the <B>ExecutableWorkpieceAsIs</B>,
<a href="#ExecutableWorkpieceToBe">ExecutableWorkpieceToBe</a>
and <a href="#ExecutableWorkpieceRemoval">ExecutableWorkpieceRemoval</a>
functions is to define additional geometry for a workingstep or other
executable so that work instructions can be given to the operator.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the STEP file that defines a geometry
model.
<DT>exe_id: <DD> The identity of an workingstep, nc function, workplan
or selective.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>:   This
function changes the placement of the workpiece so that it can be positioned
and oriented correctly within the context of the tool paths.
<li><a href="#GetCurrentWorkingstep">GetCurrentWorkingstep</a>:   Returns
the id of the current workpiece or null (0).
<li><a href="#ExecutableWorkpieceToBe">ExecutableWorkpieceToBe</a>:   Define
the To-BE geometry of a workingstep.
<li><a href="#ExecutableWorkpieceRemoval">ExecutableWorkpieceRemoval</a>:
Defined the removal geometry of a workinstep.
</UL>



<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad File: The API was unable to open a file with the given name or
it was not a valid STEP file.
<li>Bad name: The workpiece cannot have the same name as the project.
<li>Bad identity: The exe_id does not identify an executable.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceRemoval></a>ExecutableWorkpieceRemoval()</h2>
<pre>
void <b>ExecutableWorkpieceRemoval</b> (
	System::Int64 ws_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ExecutableWorkpieceRemoval()</b> function define a model of
the geometry that will be removed while the workingstep is executing.
See <a href="#ExecutableWorkpieceAsIs">ExecutableWorkpieceAsIs</a> for
more information.


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceReuseAsIs></a>ExecutableWorkpieceReuseAsIs()</h2>
<pre>
void <b>ExecutableWorkpieceReuseAsIs</b> (
	System::Int64 ws_id,
	System::Int64 wp_id
	);
</pre>

<P>The <b>ExecutableWorkpieceReuseAsIs()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceReuseRemoval></a>ExecutableWorkpieceReuseRemoval()</h2>
<pre>
void <b>ExecutableWorkpieceReuseRemoval</b> (
	System::Int64 ws_id,
	System::Int64 wp_id
	);
</pre>

<P>The <b>ExecutableWorkpieceReuseRemoval()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceReuseToBe></a>ExecutableWorkpieceReuseToBe()</h2>
<pre>
void <b>ExecutableWorkpieceReuseToBe</b> (
	System::Int64 ws_id,
	System::Int64 wp_id
	);
</pre>

<P>The <b>ExecutableWorkpieceReuseToBe()</b> function
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=ExecutableWorkpieceToBe></a>ExecutableWorkpieceToBe()</h2>
<pre>
void <b>ExecutableWorkpieceToBe</b> (
	System::Int64 ws_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ExecutableWorkpieceToBe()</b> function defines a model of
 what the geometry of the workpiece should look like after the
 workingstep has finished executing.   See
<a href="#ExecutableWorkpieceAsIs">ExecutableWorkpieceAsIs</a> for
more information.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAP238CC1></a>ExportAP238CC1()</h2>
<pre>
void <b>ExportAP238CC1</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAP238CC1()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsAPT></a>ExportAsAPT()</h2>
<pre>
void <b>ExportAsAPT</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsAPT()</b> function writes the tool paths defined for
the STEP-NC program into an APT file using the Siemens NX syntax.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name:  <DD> File
name for the APT file that is to contain the tool paths.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ReadUGSAPTclfile">ReadUGSAPTclfile</a>: Read an APT file
and use it to define the geometry of tool paths.<p>

</UL>

<h3>Common Errors</h3>
<UL>
<li>No geometry: The geometry of the fixture has not been defined in
the program.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsDmisCNC></a>ExportAsDmisCNC()</h2>
<pre>
void <b>ExportAsDmisCNC</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsDmisCNC()</b> function exports codes for CMM
machines that read DMIS programs in CNC mode.
See <a href="#ExportCNC">ExportCNC</a> for additional
discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsDmisManual></a>ExportAsDmisManual()</h2>
<pre>
void <b>ExportAsDmisManual</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsDmisManual()</b> function exports codes for CMM
machines that read DMIS programs in manual mode.
See <a href="#ExportCNC">ExportCNC</a> for additional
discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsESAB></a>ExportAsESAB()</h2>
<pre>
void <b>ExportAsESAB</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsESAB()</b> function exports codes for ESAB plate
cutting equipment.  See <a href="#ExportCNC">ExportCNC</a> for
additional discussion.

<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsFanuc></a>ExportAsFanuc()</h2>
<pre>
void <b>ExportAsFanuc</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsFanuc()</b> function exports codes for Fanuc
controls.  See <a href="#ExportCNC">ExportCNC</a> for additional
discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsHaas></a>ExportAsHaas()</h2>
<pre>
void <b>ExportAsHaas</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsHaas()</b> function exports codes for Haas CNC
equipment.  See <a href="#ExportCNC">ExportCNC</a> for
additional discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsHeidenhainAC></a>ExportAsHeidenhainAC()</h2>
<pre>
void <b>ExportAsHeidenhainAC</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsHeidenhainAC()</b> function exports codes for
Heidenhain controls with AC axes.
See <a href="#ExportCNC">ExportCNC</a> for additional
discussion.

<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsHeidenhainBC></a>ExportAsHeidenhainBC()</h2>
<pre>
void <b>ExportAsHeidenhainBC</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsHeidenhainBC()</b> function exports codes for
Heidenhain controls with BC axes.
See <a href="#ExportCNC">ExportCNC</a> for additional
discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsMDSI></a>ExportAsMDSI()</h2>
<pre>
void <b>ExportAsMDSI</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsMDSI()</b> function exports codes for MDSI lathe
controls.  See <a href="#ExportCNC">ExportCNC</a> for
additional discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsOkuma></a>ExportAsOkuma()</h2>
<pre>
void <b>ExportAsOkuma</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsOkuma()</b> function exports codes for Okuma
controls.  See <a href="#ExportCNC">ExportCNC</a> for
additional discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportAsSiemens></a>ExportAsSiemens()</h2>
<pre>
void <b>ExportAsSiemens</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExportAsSiemens()</b> function exports codes for Siemens
SINUMERIK controls.  See <a href="#ExportCNC">ExportCNC</a>
for additional discussion.


<!-- ================================ -->
<h2 class=rule>
<a name=ExportCNC></a>ExportCNC()</h2>
<pre>
void <b>ExportCNC</b> (
	System::String^ file_name,
	System::String^ style
	);
</pre>

<P>The <b>ExportCNC()</b> function converts the tool paths in a
STEP-NC program into codes suitable for execution on a partuicular
machine tool control. All of the tool paths in all of the workingsteps
and workplans of the current project are converted. If a subset is
needed then the main_workplan should be edited using the delete
functions before this function is called.

<P>The output of all types of CNC export can be customized using
functions with the<b>SetCNCExport</b> prefix.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>file_name: <DD>File name for the file that is to contain the
codes.
<DT>style: <DD>A symbolic identifier for a built in code style.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#SetCNCexportInsertStopAfterWorkings">SetCNCexportInsertStopAfterWorkingstep</a>:
Puts a stop after each workingstep to make simulation and verification
of the codes easier.
<li><a href="#SetCNCexportNumberOfDigits">SetCNCexportNumberofDigits</a>:
Sets the number of digits of precision for an export.
<li><a href="#SetCNCexportUnits">SetCNCexportUnits</a>: Sets the units
for an export.
<li><a href="#SetCNCexportUsingBlocknumbers">SetCNCexportUsingBlockNumbers</a>:
Determines if block numbers are exported.
<li><a href="#SetCNCexportUsingTCP">SetCNCexportUsingTCP</a>:
Determines if the export is to be in TCP mode.
<li>p<a href="#SetCNCexportWorkoffset">SetCNCexportWorkoffset</a>:
Determines the workoffset register.
<li><a href="#ImportFanuc">ImportFanuc</a>: Read a Fanuc file and use
it to define toolpaths.<p>
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ExportWorkpiece></a>ExportWorkpiece()</h2>
<pre>
void <b>ExportWorkpiece</b> (
	System::Int64 wp_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ExportWorkpiece()</b> function exports the geometry and
placement of a workpiece as a STEP CAD file so that it can be read by
another application. The workpiece can be a rawpiece, fixture,
in-process geoemetry as well as the workpiece of the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD> The identifier for a workpiece.
<DT>file_name: <DD> File name for the STEP CAD file that is to contain
the workpiece.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: This function defines a
placement for a workpiece.
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: This
function returns the identity of the current program workpiece.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: This
function returns the identity of the rawpiece of the current program
workpiece.
<li><a href="#GetCurrentFixture">GetCurrentFixture</a>: This function
returns the identity of the current fixture model.
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>:
This function returns the identity of the workpiece that defines the
as-is (before machining) geometry for a workinstep.
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
This function returns the identity of the workpiece that defines the
to-be (after machining) geometry for a workinstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
This function returns the identity of the workpiece that defines the
removal volume for a workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No geometry: The geometry of the workpiece has not been defined in
the program.
<li>Bad identity: The wp_id does not identify a workpiece.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ExtendedNcFunction></a>ExtendedNcFunction()</h2>
<pre>
void <b>ExtendedNcFunction</b> (
	System::String^ label,
	System::String^ description
	);
</pre>

<P>The <b>ExtendedNcFunction()</b> function adds a user-defined NC
function entry in the STEP-NC programs.  Use of extended NC functions
is strongly discouraged because they prevent portability.

<P>Nevertheless there are situations where an extended NC function is
the only solution. The two most common are while testing potential new
STEP-NC functionality and to enable a unique feature of a unique
machine.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD> An optional label for the new function.
<DT>description: <DD> The text to be passed to the
controller. Frequently the text describes a Macro that will be
expanded on the controller
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExtendedNcFunctionAfter">ExtendedNcFunctionAfter</a>:
Inserts the extended nc function into a given location in the STEP-NC
program.<p>
</UL>

<h3>Common Errors</h3>
<UL>
<li> No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=ExtendedNcFunctionAfter></a>ExtendedNcFunctionAfter()</h2>
<pre>
System::Int64 <b>ExtendedNcFunctionAfter</b> (
	System::String^ label,
	System::String^ description,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>ExtendedNcFunctionAfter()</b> function inserts an extended
NC function into a given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD> An optional label for the new function.
<DT>Description: <DD> The text to be passed to the controller of the
chosen machine. Frequently the text describes a Macro that will be
expanded on the controller
<DT>Index: <DD> The desired position for the function in the workplan.
<DT>Plan_id: <DD> The identity of the workplan that is to contain the
new function. See Section for some important notes on how to use
identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExtendedNcFunction">ExtendedNcFunction</a>: Adds the
extended nc function to the current end of the STEP-NC program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ExternalOperation></a>ExternalOperation()</h2>
<pre>
void <b>ExternalOperation</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ExternalOperation()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=Feedrate></a>Feedrate()</h2>
<pre>
void <b>Feedrate</b> (
	double speed
	);
</pre>

<P>The <b>Feedrate()</b> function defines the feedrate to be used by
all subsequent tool paths.  The unit of the feedrate is given using
the <a href="#FeedrateUnit">FeedrateUnit</a> function.

<P>If a toolpath is currently being constructed then it is finished
and a new one is started for the next new geometry item with the new
feedrate. If the system is currently in rapid mode then this mode is
cancelled.


<h3>Arguments</h3>
<DL class=termdefs>
<DT>Speed: <DD>The value for the new speed. The feedrate function does
nothing if the new feed is the same as the current speed and the
system is not in rapid mode.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#FeedrateUnit">FeedrateUnit</a>: Sets the unit to be used
by all subsequent feedrates.
<li><a href="#FeedrateCSS">FeedrateCSS</a>: Used to define a constant
spindle speed feedrate for turning applications.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: Used to define the
spindle speed.
<li><a href="#Rapid">Rapid</a>: This function sets the system into
rapid mode for all subsequent tool paths.
<li><a href="#Arc">Arc</a>: This function adds arc segments to the
geometry that will be given the new feedrate.
<li><a href="#GoToXYZ">GoToXYZ</a>: This function adds line segments
to the geometry that will be given the new feedrate.<p>
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=FeedrateCSS></a>FeedrateCSS()</h2>
<pre>
void <b>FeedrateCSS</b> (
	double value,
	double max
	);
</pre>

<P>The <b>FeedrateCSS()</b> function defines a constant spindle speed
feedrate for turning applications.

<P>If a toolpath is currently being constructed then it is finished
and a new one is started with the new feedrate.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Speed: <DD>The value for the new speed. The feedrate function does
nothing if the new feed is the same as the current speed.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#FeedrateUnit">FeedrateUnit</a>: Sets the feedrate for
milling applications.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: Used to define the
spindle speed.
<li><a href="#SetModeTurn">SetModeTurn</a>: Puts the API into turning
mode.
<li><a href="#SetModeMill">SetModeMill</a>: Puts the API back into the
milling mode (the default).<p>
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Not in turn mode: FeedrateCSS can only be used for turning
applications.
<li>The functionality of the API for turning applications is weak
compared to its functionality for milling applications.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=FeedrateUnit></a>FeedrateUnit()</h2>
<pre>
void <b>FeedrateUnit</b> (
	System::String^ unit
	);
</pre>

<P>The <b>FeedrateUnit()</b> function defines the feedrate units to be
used for all subsequent tool paths and sets the current feedrate to
0. The function should be followed by a call
to <a href="#Feedrate">Feedrate</a> to set a new feedrate value.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Unit: <DD> The unit to be used for future feedrates as described
by one of the following strings:
<UL>
<li> &ldquo;mmps&rdquo; millimeters per second
<li> &ldquo;mmpm&rdquo; millimeters per minute
<li> &ldquo;cmps&rdquo; centimeters per second
<li> &ldquo;mps&rdquo; meters per second
<li> &ldquo;ips&rdquo; inches per second
<li> &ldquo;ipm&rdquo; inches per minute
<li> &ldquo;fps&rdquo; feet per second
<li> &ldquo;fpm&rdquo; feet per minute
<li> &ldquo;iprev&rdquo; inches per revolution
<li> &ldquo;mmprev&rdquo; millimeters per revolution
</UL>
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Feedrate">Feedrate</a>: Sets feedrate value.
<li><a href="#GetCurrentTech">GetCurrentTech</a>: Returns
the identifier of the current technology object. Will be NULL when new
feedrate units or spindle speed units have been set but not yet
used.<p>
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Invalid string: The string describing the units does not have one
of the values recognized by the STEP-NC API.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=FirstPathStartAxis></a>FirstPathStartAxis()</h2>
<pre>
void <b>FirstPathStartAxis</b> (
	double i,
	double j,
	double k
	);
</pre>

<P>The <b>FirstPathStartAxis()</b> function defines the initial values
to be used for the tool axis at the start of a program or after the
tool has been changed if no other axis has been given.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>i, j, k: <DD> The components of the axis.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#FirstPathStartPoint">FirstPathStartPoint</a>: The x, y
and z values to be used after the tool change.
<li><a href="#LoadTool">LoadTool</a>: The function to change the tool.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=FirstPathStartPoint></a>FirstPathStartPoint()</h2>
<pre>
void <b>FirstPathStartPoint</b> (
	double x,
	double y,
	double z
	);
</pre>

<P>The <b>FirstPathStartPoint()</b> function defines a start point to
be used for the tool path at the start of a program or after the tool
has been changed if no other point has been given.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>The coordinates of the point.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#FirstPathStartAxis">FirstPathStartAxis</a>: The i, j and
k values to be used for the tool axis.
<li><a href="#LoadTool">LoadTool</a>: The function to change the tool.
<li>There is no FirstPathStartNormal because the tool should not be in
contact with a surface immediately after a tool change.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Fixture></a>Fixture()</h2>
<pre>
void <b>Fixture</b> (
	System::String^ filename
	);
</pre>
<pre>
void <b>Fixture</b> (
	System::Int64 	plan_id;
	System::String^ filename
	);
</pre>

<P>The <b>Fixture()</b> function defines a fixture for the current workplan
or the explicitly given workplan usign a CAD file. If a workplan has no
fixture defined then it may be inherited from it parent workplan.
A fixture is an assembly and may be defined as STEP AP203, AP214 or AP242.


<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan that is to be given the fixture.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="Finder.html#IsWorkplanWithSetupAndFixture">IsWorkplanWithSetupAndFixture</a>: Finder function that
returns true (1) if the workplan has a fixture defined.
<li><a href="#DeleteFixture">DeleteFixture</a>: Delete the fixture reference of a
workplan. 


</UL>




<!-- ================================ -->
<h2 class=rule>
<a name=GenerateToolGeometry></a>GenerateToolGeometry()</h2>
<pre>
void <b>GenerateToolGeometry</b> (
	System::Int64 tl_or_ws_id
	);
</pre>

<P>The <b>GenerateToolGeometry()</b> function generates a geometry
model for a tool using the current values of its diameter, length and
corner radius. See the process object for functions that can set and
get these values.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tl_or_ws_id: <DD>Internal object identifier for the tool or a workingstep that uses the tool.
</DL>



<!-- ================================ -->
<h2 class=rule>
<a name=GeometryForTool></a>GeometryForTool()</h2>
<pre>
void <b>GeometryForTool</b> (
	System::Int64 tl_id,
	System::String^ filename
	);
</pre>

<P>The <b>GeometryForTool()</b> function imports tool geometry when
given the internal object identifier for a tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>Internal object identifier for the tool
<DT>filename<DD>STEP CAD file containing the tool geometry
</DL>



<!-- ================================ -->
<h2 class=rule>
<a name=GeometryForToolNumber></a>GeometryForToolNumber()</h2>
<pre>
void <b>GeometryForToolNumber</b> (
	System::String^ file_name,
	System::Int64 number
	);
</pre>

<P>The <b>GeometryForToolNumber()</b> function is a simpler interface
for the <a href="#ToolGeometry">ToolGeometry</a>
and <a href="#SetToolIdentifier">SetToolIdentifier</a> functions. It
is defined from these functions as follow as follows:

<PRE class=code>
Step-&gt;GeometryForToolNumber (&ldquo;geometry_file&rdquo;, 1);
</PRE>

Is equivalent to:

<PRE class=code>
Step-&gt;<a href="#ToolGeometry">ToolGeometry</a> (&ldquo;geometry_file&rdquo;, &ldquo;T1&rdquo;);
Step-&gt;<a href="#SetToolIdentifier">SetToolIdentifier</a> (&ldquo;1&rdquo;, &ldquo;T1&rdquo;);
</PRE>

<P>This function assumes that tool numbers are integers. The other two
functions allow the tool number to be any identifier.  Geometry for
tool number prepends a &ldquo;T&rdquo; to the tool number to define an
identifier for the tool. Therefore, in the above example the tool will
be given the identifier &ldquo;T1&rdquo;.



<!-- ================================ -->
<h2 class=rule>
<a name=GetCNCexportActualFlutes></a>GetCNCexportActualFlutes()</h2>
<pre>
System::Int64 <b>GetCNCexportActualFlutes</b> (
	System::Int64 tl_id
	);
</pre>

<P>The <b>GetCNCexportActualFlutes()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetCNCexportExecIsEnabled></a>GetCNCexportExecIsEnabled()</h2>
<pre>
System::Boolean <b>GetCNCexportExecIsEnabled</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>GetCNCexportExecIsEnabled()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetCNCexportExecSpeedprofileActive></a>GetCNCexportExecSpeedprofileActive()</h2>
<pre>
System::Boolean <b>GetCNCexportExecSpeedprofileActive</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>GetCNCexportExecSpeedprofileActive()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentFeed></a>GetCurrentFeed()</h2>
<pre>
double <b>GetCurrentFeed</b> ();
</pre>

<P>The <b>GetCurrentFeed()</b> function returns a double, the value
last set using the <a href="#Feedrate">Feedrate</a> function.  This is
the current value of the feed variable and will be used for any new
toolpath data until it is reset by another call to
the <a href="#Feedrate">Feedrate</a>
or <a href="#FeedrateUnit">FeedrateUnit</a> function.

<h3>Related Functions</h3>
<UL>
<li><a href="#Feedrate">Feedrate</a>:  This function sets the value
of the feed variable.
<li><a href="#FeedrateUnit">FeedrateUnit</a>: This function changes
the unit that will be used for feeds and resets the value of the feed
variable to zero.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentFixture></a>GetCurrentFixture()</h2>
<pre>
System::Int64 <b>GetCurrentFixture</b> ();
</pre>

<P>The <b>GetCurrentFixture()</b> function returns the integer
identifier of the current fixture so that it can be used as an
argument for the functions that work on any kind of workpiece.  The
return value will be zero if there is no current fixture.


<h3>Related Functions</h3>
<UL>
<li><a href="#Fixture">Fixture</a>: This function defines the geometry
of the fixture from an STEP CAD file.
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: Sets the placement of
the fixture using the identifier returned by GetCurrentFixture.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentFunction></a>GetCurrentFunction()</h2>
<pre>
System::Int64 <b>GetCurrentFunction</b> ();
</pre>

<P>The <b>GetCurrentFunction()</b> function returns the integer
identifier of the object that is currently being used to define the
machine functions for new tool paths and workingsteps. The machine
functions are used to control attributes such as the coolant. If the
coolant changes then a functions object with the new value is made the
current functions object.  The return value will be zero if there is
no machine functions object.


<h3>Related Functions</h3>
<UL>
<li><a href="#CoolantMist">CoolantMist</a>: One of the functions that
changes the coolant value. See also <a href="#CoolantOn">CoolantOn</a>
and <a href="#CoolantOff">CoolantOff</a>.

</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentLastExecutable></a>GetCurrentLastExecutable()</h2>
<pre>
System::Int64 <b>GetCurrentLastExecutable</b> ();
</pre>

<P>The <b>GetCurrentLastExecutable()</b> function returns the integer
identifier of the last executable. An executable may be a workingstep,
an NC function, a workplan or a selective.  The return value cannot be
zero because every project contains at least one workplan.

<h3>Related Functions</h3>
<UL>The <a href=Finder.html>Finder</a> object contains functions for
testing the type of an executable.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentLocation></a>GetCurrentLocation()</h2>
<pre>
void <b>GetCurrentLocation</b> (
	[System::Runtime::InteropServices::Out] double %x,
	[System::Runtime::InteropServices::Out] double %y,
	[System::Runtime::InteropServices::Out] double %z,
	[System::Runtime::InteropServices::Out] double %i,
	[System::Runtime::InteropServices::Out] double %j,
	[System::Runtime::InteropServices::Out] double %k
	);
</pre>

<P>The <b>GetCurrentLocation()</b> function returns coordinates that
will be used as the start position for the next geometry item.

<h3>Result</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>Coordinates set by the last geometry item or by
the <a href="#FirstPathStartPoint">FirstPathStartPoint</a>
function. If both these have not been set than the values (0, 0, 0)
will be returned
<DT>i, j, k: <DD>Axis set by the last geometry item or by
the <a href="#FirstPathStartAxis">FirstPathStartAxis</a> function. If
bith these have not been set then the value (0, 0, 1) will be
returned.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GoToXYZ">GoToXYZ</a>:  Adds a line to the current tool
path and sets a new current location.
<li><a href="#Arc">Arc</a>:  Adds an arc to the current tool
path and sets a new current location.
<li><a href="#FirstPathStartPoint">FirstPathStartPoint</a>: Sets the
coordinates for the first point after a tool change.
<li><a href="#FirstPathStartAxis">FirstPathStartAxis</a>: Sets the
components for the first axis after a tool change. <p>
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentNormals></a>GetCurrentNormals()</h2>
<pre>
void <b>GetCurrentNormals</b> (
	[System::Runtime::InteropServices::Out] double %sa,
	[System::Runtime::InteropServices::Out] double %sb,
	[System::Runtime::InteropServices::Out] double %sc,
	[System::Runtime::InteropServices::Out] double %rda,
	[System::Runtime::InteropServices::Out] double %rdb,
	[System::Runtime::InteropServices::Out] double %rdc
	);
</pre>

<P>The <b>GetCurrentNormals()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentProject></a>GetCurrentProject()</h2>
<pre>
System::Int64 <b>GetCurrentProject</b> ();
</pre>

<P>The <b>GetCurrentProject()</b> function returns the integer
identifier of the current project so that it can be used to find that
project at a later time. See Section for some important notes on how
to use identifiers.  The return value cannot be zero because every
STEP-NC program contains a project.

<h3>Related Functions</h3>
<UL>
<li><a href="#NewProject">NewProject</a>: This function starts a new
project.
<li><a href="#Open238">OpenProject</a>: This function makes the project in
an AP-238 file the current project.
<li><a href="#Open224">Open224</a>: This function reads an AP-224 file
and constructs a project containing that file.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentRawpiece></a>GetCurrentRawpiece()</h2>
<pre>
System::Int64 <b>GetCurrentRawpiece</b> ();
</pre>

<P>The <b>GetCurrentRawpiece()</b> function returns the integer
identifier of the current rawpiece so that it can be used as an
argument for the functions that work on any kind of workpiece. See
Section for some important notes on how to use identifiers.  The
return value will be zero if there is no current rawpiece.

<h3>Related Functions</h3>
<UL>
<li><a href="#Rawpiece">Rawpiece</a>:  This function defines the
rawpiece from an STEP CAD file.
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: This function uses the
result of GetCurrentRawpiece to set the placement of the rawpiece.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentSpeed></a>GetCurrentSpeed()</h2>
<pre>
double <b>GetCurrentSpeed</b> ();
</pre>

<P>The <b>GetCurrentSpeed()</b> function returns a double giving the
current value of the spindle speed variable. This value is set by
the <a href="#SpindleSpeed">SpindleSpeed</a> function and it is the
value that will be used for any new toolpath data until it is reset by
another call to the <a href="#SpindleSpeed">SpindleSpeed</a>
or <a href="#SpindleSpeedUnit">SpindleSpeedUnit</a> functions.


<h3>Related Functions</h3>
<UL>
<li><a href="#SpindleSpeed">SpindleSpeed</a>:  This function sets the value
of the spindle speed variable.
<li><a href="#SpindleSpeedUnit">SpindleSpeedUnit</a>: This function
changes the unit that will be used for speeds and resets the value of
the spindle speed variable to zero.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentTech></a>GetCurrentTech()</h2>
<pre>
System::Int64 <b>GetCurrentTech</b> ();
</pre>

<P>The <b>GetCurrentTech()</b> function returns the integer identifier
of the object that is currently being used to define the machine
technology for new tool paths and workingsteps. The machine technology
is used to control the feedrate and spindle speed of a tool path.  The
return value will be zero if there is no machine technology object.


<h3>Related Functions</h3>
<UL>
<li><a href="#Feedrate">Feedrate</a>: A function that changes the
feedrate and therefore the current technology object. The technology
object will be NULL until a new toolpath needs the object.
<li><a href="#FeedrateUnit">FeedrateUnit</a>: A function that changes
the feedrate units and therefore the current technology object. The
technology object will be NULL until a new toolpath needs the object.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: A function that changes
the spindle speed and therefore the current technology object. The
technology object will be NULL until a new toolpath needs the object.
<li><a href="#SpindleSpeedUnit">SpindleSpeedUnit</a>: A function that
changes the spindle speed unit and therefore the current technology
object. The technology object will be NULL until a new toolpath needs
the object.
<li><a href="#GoToXYZ">GoToXYZ</a>, <a href="#Arc">Arc</a>: Add a
geometry item to the current tool path so a technology object will be
found or defined with the values currently set for the feed and
speed.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentTool></a>GetCurrentTool()</h2>
<pre>
System::Int64 <b>GetCurrentTool</b> ();
</pre>

<P>The <b>GetCurrentTool()</b> function returns the identifier of the
current tool so that it can be used to find that tool at a later
time. See Section for some important notes on how to use
identifiers. The id returned by this function is <u>NOT</u> the tool
number or the tool identifier. These values can be found using
the <a href="Finder.html#GetToolNumber">GetToolNumber</a>
and <a href="Finder.html#GetToolIdentifier">GetToolIdentifier</a>
functions of the <a href="Finder.html">Finder</a> object.  The return
value will be zero if there is no current tool.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#LoadTool">LoadTool</a>:  Picks the current tool for the
next workingstep and changes the value that will be returned by GetCurrentTool.
<li><a href="#GetToolNumber">GetToolNumber</a>:  Gets the number of a tool.
<li><a href="#GetToolIdentifier">GetToolIdentifier</a>: Gets the
identifier of a tool
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentToolpath></a>GetCurrentToolpath()</h2>
<pre>
System::Int64 <b>GetCurrentToolpath</b> ();
</pre>

<P>The <b>GetCurrentToolpath()</b> function returns the integer
identifier of the current tool path so that it can be used to find
that path at a later time.  The return value will be zero if there is
no current tool path.

<p>The <a href="#LoadTool">LoadTool</a>,
<a href="#SpindleSpeed">SpindleSpeed</a>, <a href="#Feedrate">Feedrate</a>
and <a href="#CoolantMist">Coolant</a> functions require a new tool
path to be started. Other functions may also require a new toolpath to
be started. The GetCurrentToolpath() function is useful because it
shows when the current path has changed, but in most cirumstances
the <a href="Finder.html">Finder</a> object contains much richer
functionality for finding toolpaths.

<h3>Related Functions</h3>
<UL>
<li><a href="#LoadTool">LoadTool</a>:  Starts a new workingstep and by
implication a new tool path if any geometry is added to that workingstep.
<li><a href="#Feedrate">Feedrate</a>:  Changes the feedrate and
requires a new tool path to be started for the next geometry item.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentWorkingstep></a>GetCurrentWorkingstep()</h2>
<pre>
System::Int64 <b>GetCurrentWorkingstep</b> ();
</pre>

<P>The <b>GetCurrentWorkingstep()</b> function returns the identifier
of the current working step so that it can be used to find that step
at a later time. The return value will be zero if there is no current
workingstep.

<p>The <a href="#LoadTool">LoadTool</a>
and <a href="#NestWorkplan">NestWorkplan</a> require a new workingstep
to be started. Other functions may also require a new working step to
be started. The GetCurrentWorkingstep function is useful because it
shows when the current workingstep has changed, but in most
cirumstances the Finder object contains much richer functionality for
finding workingsteps.

<h3>Related Functions</h3>
<UL>
<li><a href="#LoadTool">LoadTool</a>:  Starts a new workingstep.
<li><a href="#NestWorkplan">NestWorkplan</a>: Starts a new workplan
and by implication any function that creates working step data will
require a new one to be created.
<li><a href="#EndWorkplan">EndWorkplan</a>: Ends the current workplan
and by implication the current workingstep as well.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentWorkpiece></a>GetCurrentWorkpiece()</h2>
<pre>
System::Int64 <b>GetCurrentWorkpiece</b> ();
</pre>

<P>The <b>GetCurrentWorkpiece()</b> function returns the integer
identifier of the current workpiece so that it can be used to find
that workpiece at a later time.  The return value cannot be zero
because there is always a current workpiece.

<p>Every project must have a workpiece, but this workpiece need not
have any geometry defined. When a project is first defined it is given
a workpiece with a default name. The default name is &ldquo;unnamed
workpiece&rdquo;. This name can be changed using
the <a href="#PartNo">PartNo</a> function, and
the <a href="#Workpiece">Workpiece</a> function. The latter also
defines geometry for the workpiece.

<P>In a STEP-NC program there is a workpiece and there are generic
workpieces and this can be confusing. Every geometry model is a
workpiece so the rawpiece, fixture tool geometry models and in-process
geometry models all count as workpieces in the generic sense.

<P>In addition every workplan has a specific workpiece that is being
made by the operations in that workplan. The workpiece of a workplan
can be defined using
the <a href="#WorkplanWorkpiecePlacementAdd">WorkplanWorkpiecePlacementAdd</a>
command. In most cases, however, a workplan just uses the default
workpiece defined for the whole project by
the <a href="#Workpiece">Workpiece</a> function.


<h3>Related Functions</h3>
<UL>
<li><a href="#Workpiece">Workpiece</a>: This function defines the
workpiece from a STEP CAD file.
<li><a href="#PartNo">PartNo</a>:  Defines a workpiece with a name
but no geometry.
<li><a href="#NewProject">NewProject</a>: Starts a new project and by
implication a new workpiece with the default name &ldquo;unnamed
workpiece&rdquo;.
<li><a href="#GetPlacement">GetPlacement</a>: This function uses the
result of GetCurrentWorkpiece.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetCurrentWorkplan></a>GetCurrentWorkplan()</h2>
<pre>
System::Int64 <b>GetCurrentWorkplan</b> ();
</pre>

<P>The <b>GetCurrentWorkplan()</b> function returns the identifier of
the current workplan. The return value cannot be zero because there is
always a current workpiece.  When a new project is started or an old
project is read from a file, the current workplan is the main workplan
of the project. The <a href="#NestWorkplan">NestWorkplan</a>
and <a href="#EndWorkplan">EndWorkplan</a> functions change the
current workplan.

<h3>Related Functions</h3>
<UL>
<li><a href="#NewProject">NewProject</a>:  This function starts a new
project and by implication a new main workplan for that project.
<li><a href="#Open238">OpenProject</a>:  This function makes the main
workplan in an AP-238 file the current workplan.
<li><a href="#NestWorkplan">NestWorkplan</a>:  This function makes a new
workplan that becomes the current workplan.
<li><a href="#EndWorkplan">EndWorkplan</a>:  This function ends the current
workplan and returns the &ldquo;currency&rdquo; to the previous workplan.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableIsEnabled></a>GetExecutableIsEnabled()</h2>
<pre>
System::Int64 <b>GetExecutableIsEnabled</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>GetExecutableIsEnabled()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableIsReachable></a>GetExecutableIsReachable()</h2>
<pre>
System::Int64 <b>GetExecutableIsReachable</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>GetExecutableIsReachable()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableWorkpieceAsIs></a>GetExecutableWorkpieceAsIs()</h2>
<pre>
System::Int64 <b>GetExecutableWorkpieceAsIs</b> (
	System::Int64 ex_id
	);
</pre>

<P>The <b>GetExecutableWorkpieceAsIs()</b> function returns the
identity of the workpiece that defines what the geometry of the part
should look like before the workingstep begins executing.  The return
value will be zero if no geometry is defined.

<P>The intent of the ExecutableWorkpieceAsIs, ExecutableWorkpieceToBe
and ExecutableWorkpieceRemoval workpieces is to define additional
geometry for a workingstep or other executable so that work
instructions can be given to the operator.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD> The identity of an workingstep, nc function, workplan
or selective.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: This function changes
the placement of the workpiece so that it can be positioned and
oriented correctly within the context of the tool paths.
<li><a href="#GetCurrentWorkingstep">GetCurrentWorkingstep</a>:
Returns the id of the current workpiece or null (0).
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
The TO-BE geometry of the workingstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
The removal geometry of a workingstep.
<li><a href="#ExecutableWorkpieceAsIs">ExecutableWorkpieceAsIs</a>:
Define the AS-IS geometry of a workingstep
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The exe_id does not identify an executable.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableWorkpieceFixture></a>GetExecutableWorkpieceFixture()</h2>
<pre>
System::Int64 <b>GetExecutableWorkpieceFixture</b> (
	System::Int64 ex_id
	);
</pre>

<P>The <b>GetExecutableWorkpieceFixture()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableWorkpieceRemoval></a>GetExecutableWorkpieceRemoval()</h2>
<pre>
System::Int64 <b>GetExecutableWorkpieceRemoval</b> (
	System::Int64 ex_id
	);
</pre>

<P>The <b>GetExecutableWorkpieceRemoval()</b> function returns the
integer identifier of the workpiece that defines a model of what will
be removed from the part while the workingstep is executing.
See <a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>.



<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableWorkpieceToBe></a>GetExecutableWorkpieceToBe()</h2>
<pre>
System::Int64 <b>GetExecutableWorkpieceToBe</b> (
	System::Int64 ex_id
	);
</pre>

<P>The <b>GetExecutableWorkpieceToBe()</b> function returns the
integer identifier of the workpiece that defines a model of what the
part should look like after the workingstep has finished executing.
See <a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>.




<!-- ================================ -->
<h2 class=rule>
<a name=GetExecutableWorkpieceTool></a>GetExecutableWorkpieceTool()</h2>
<pre>
System::Int64 <b>GetExecutableWorkpieceTool</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>GetExecutableWorkpieceTool()</b> function defines the tool
of a workingstep and makes it possible for an application to get all
of the geometries that are specific to a workinstep using the
GetExecutableWorkpiece functions.
See <a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>.

<!-- ================================ -->
<h2 class=rule>
<a name=GetFrameDefinitionAllNext></a>GetFrameDefinitionAllNext()</h2>
<pre>
System::Int64 <b>GetFrameDefinitionAllNext</b> (
	System::Int64 index
	);
</pre>

<P>The <b>GetFrameDefinitionAllNext()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetFrameDefinitionBestGuessForExecutable></a>GetFrameDefinitionBestGuessForExecutable()</h2>
<pre>
System::Int64 <b>GetFrameDefinitionBestGuessForExecutable</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>GetFrameDefinitionBestGuessForExecutable()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetFrameDefinitionCount></a>GetFrameDefinitionCount()</h2>
<pre>
System::Int64 <b>GetFrameDefinitionCount</b> ();
</pre>

<P>The <b>GetFrameDefinitionCount()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetSetupAllNext></a>
<a name=GetSetupAllCount></a>GetSetupAllCount/Next()</h2>
<pre>
System::Int64 <b>GetSetupAllCount</b> ();

System::Int64 <b>GetSetupAllNext</b> (
	System::Int64 index
	);
</pre>

<P>The <b>GetSetupAllCount()</b> function returns a count of the
number of setups in the project and the <b>GetSetupAllNext()</b>
function returns the identity of the next setup in the project.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>index: <DD> The position of the desired setup.
</DL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Range: The index is not in the range [0, count-1].
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetSetupBestGuessForExecutable></a>GetSetupBestGuessForExecutable()</h2>
<pre>
System::Int64 <b>GetSetupBestGuessForExecutable</b> (
	System::Int64 exe_id
	);
</pre>

<P>The <b>GetSetupBestGuessForExecutable()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=GetToolId></a>GetToolId()</h2>
<div class = "tabview">
<pre class=".net">
System::Int64 <b>GetToolId</b> (
	System::String^ tool_number
	);
</pre>
<pre class="node.js">
int <b>GetToolEID</b>(
	string tool_number
	);
</pre>
<pre class="C++">
RoseBoolean <b>get_tool_id</b> (
	const char *number,
	int &tl_id
	);
</pre>
</div>
<P>The <b>GetToolId()</b> function returns the entity id of the tool object associated with a tool number.
APT programs identify a tool using a tool number. STEP programs identify an object using the entity id of its
root in a STEP file.
Functions in the API that build STEP-NC data from APT use the tool number. Most other functions using the
entity id. Occassionally there may be situations where you need to use the entity id but only have the tool number.
In these situations this function will give you the required entity id from the tool number.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tool_number: <DD>The tool number (as a string because STEP-NC
allows any value for the number).
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#GetToolNumber">GetToolNumber</a>:   Get the APT tool number
from an entity id.
<li><a href="#SetToolNumber">SetToolNumber</a>:   Change the APT tool number.
<li>The <a href="Finder.html">Finder</a>
and <a href="Tolerance.html">Tolerance</a> objects contain a range of
funtions for finding tools using their numbers, identifiers and their
relationships to other objects.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetToolIdentifier></a>GetToolIdentifier()</h2>
<div class = "tabview">
<pre class=".net">
System::String^ <b>GetToolIdentifier</b> (
	System::String^ tool_number
	);
</pre>
<pre class="node.js">
string <b>GetToolIdentifier</b> (
	string tool_number
	);
</pre>
<pre class="C++">
RoseBoolean <b>get_tool_number</b> (
	int ws_id,
	const char * &tool_number
	);
</pre>
</div>
<P>The <b>GetToolIdentifier()</b> function returns the string
identifier of a tool.  This is the manufacturers name for the
tool. This name is used to search for information about the tool in
manufacturers catalogs and ISO 13399 files.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tool_number: <DD>The tool number (as a string because STEP-NC
allows any value for the number).
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#SetToolIdentifier">SetToolIdentifier</a>:   Set the
tool identifier.
<li><a href="#DefineTool2">DefineTool2</a>:   Defines a
tool with an identifier.
<li><a href="#LoadISO13399Data">LoadISO13399Data</a>:   Load the
manufacturer&rsquo;s data for the tools in a program.
<li><a href="#ToolGeometry">ToolGeometry</a>:   Define the
geometry for a tool using its identifier.
<li><a href="#ExportToolGeometry">ExportToolGeometry</a>:   Export the
geometry for a tool using its identifier.
<li><a href="#DeleteToolGeometry">DeleteToolGeometry</a>:   Delete the
geometry for a tool using its identifier.
<li><a href="#GetToolNumber">GetToolNumber</a>:   Get the number
of the tool used in a workingstep (so that it can be used as an argument for
this function).
<li>The <a href="Finder.html">Finder</a>
and <a href="Tolerance.html">Tolerance</a> objects contain a range of
funtions for finding tools using their numbers, identifiers and their
relationships to other objects.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetToolNumber></a>GetToolNumber()</h2>
<div class = "tabview">
<pre class=".net">
System::String^ <b>GetToolNumber</b> (
	System::Int64 ws_or_tl_id
	);
</pre>
<pre class="node.js">
string <b>GetToolNumber</b> (
	int id
	);
</pre>
<pre class="C++">
RoseBoolean <b>get_tool_number</b> (
	int ws_id,
	const char * &tool_number
	);
</pre>
</div>
<P>The <b>GetToolNumber()</b> function returns the tool number as a
string.  Traditionally this is an integer that corresponds to the
position of the tool in a tool carousel. STEP-NC allows any string to
be the tool number, but the APT Parser functions require the tool
number to be an integer so the continued use of integers is strongly
recommended.

<p>The tool number should not be confused with the tool
identifier. The tool identifier is a manufacturer&rsquo;s name for a
tool. There can be many instances of a tool with a particular
identifier.  Each instance will have a different number and be used in
a different workingstep, but will share its tool geometry and
manufacturers information with other tools that have the same
identifier.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id: <DD> The identity of a workingstep.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GetToolIdentifier">GetToolIdentifier</a>:   Get the identifier
of a tool using its number.
<li><a href="#SELCTLTool">SELCTLTool</a>:   Sets the number
for a tool if it was not generated automatically.
<li><a href="#SetToolAutoNumberOn">SetToolAutoNumberOn</a>:   Controls the
automatic generation of tool numbers.
<li><a href="#LoadTool">LoadTool</a>:   Loads a tool
using its number and makes it the current tool for subsequent workingsteps.
<li><a href="#DefineTool">DefineTool</a>:   Make a new
tool.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetUUID></a>GetUUID()</h2>
<div class = "tabview">
<pre class=".net">
System::String^ <b>GetUUID</b> (
	System::Int64 entity_id
	);
</pre>
<pre class="node.js">
string <b>GetUUID</b> (
	int EID
	);
</pre>
<pre class="C++">
RoseBoolean <b>get_uuid</b> (
	int ent_id,
	const char * &uuid
	);
</pre>
</div>
<P>The <b>GetUUID()</b> function returns the Universally Unique IDentifier
currently assigned to an entity or NULL. A UUID is a number that in practice
will never be generated again.


<h3>Arguments</h3>
<DL class=termdefs>
<DT>entity_id: <DD> The internal (STEP Part 21) identity of an entity.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SetUUID">SetUUID_force()</a>:   Give the entity a new UUID.
This should happen whenever the value of the concept rooted by the
entity changes.
<li><a href="#SetUUID">SetUUID_if_not_set()</a>: Set the UUID of an
entity if it is not currently set.
<li><a href="#SetUUID">SetUUID_to_string()</a>: Set the UUID of an
entity to a given string which must be unique.
<li><a href="#SetName">SetName()</a>: Set the name of an entity to a given string.</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>

<a name=GetWorkpieceExecutableNext></a>
<a name=GetWorkpieceExecutableCount></a>GetWorkpieceExecutableCount/Next()</h2>
<div class="tabview">
<pre class=".net">
System::Int64 <b>GetWorkpieceExecutableCount</b> (
	System::Int64 wp_id
	);

System::Int64 <b>GetWorkpieceExecutableNext</b> (
	System::Int64 wp_id,
	System::Int64 index
	);
</pre>
<pre class="node.js">
int[] <b>GetWorkpieceExecutableAll</b> (
	int wp_id
	);
</pre>
<pre class="C++">
RoseBoolean <b>workpiece_executable_count</b> (
	int wp_id, int &count
	);

RoseBoolean <b>workpiece_executable_next</b> (
	int wp_id, 
	int index, 
	int &exe_id
	);
</pre>
</div>

<P>The <b>GetWorkpieceExecutableCount()</b> function returns the
number of workingsteps and workplans that refer to the workpiece.  The
workpiece might appear as the "as-is" shape, the "to-be" shape, or the
"removal/delta" shape.

<P>The <b>GetWorkpieceExecutableNext()</b> function iterates over the
executables and returns the one at a given index.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD>The identity of a workpiece.
<DT>index: <DD> The position of the desired executable.
</DL>

<!-- ================================ -->
<h2 class=rule>
<a name=GetWorkpiecePlacement></a>GetWorkpiecePlacement()</h2>
<pre>
void <b>GetWorkpiecePlacement</b> (
	System::Int64 wp_id,
	[System::Runtime::InteropServices::Out] double %x,
	[System::Runtime::InteropServices::Out] double %y,
	[System::Runtime::InteropServices::Out] double %z,
	[System::Runtime::InteropServices::Out] double %i,
	[System::Runtime::InteropServices::Out] double %j,
	[System::Runtime::InteropServices::Out] double %k,
	[System::Runtime::InteropServices::Out] double %a,
	[System::Runtime::InteropServices::Out] double %b,
	[System::Runtime::InteropServices::Out] double %c
	);
</pre>

<P>The <b>GetWorkpiecePlacement()</b> function returns the axis
placement that currently defines the position and orientation of a
geometry model. See
the <a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>
function for a description of the parameters used to set the position
and orientation. This function returns the current value of these
parameters

<h3>Arguments</h3>
<DL class=termdefs>
<DT>id <DD>The identity of a model. The model may be a fixture, tool
rawpiece or workpiece and it may describe the as-is, to-be or removal
volumes for a workingstep, workplan or executable.
</DL>

<h3>Result</h3>
<DL class=termdefs>
<DT>x, y, z <DD>The coordinates of the placement point.
<DT>i, j, k <DD>The coordinates of the placement z axis.
<DT>a, b, c <DD>The coordinates of the placement x axis
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: Set
the current placement values for a model.
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Get the
identity of the current workpiece.
<li><a href="#GetCurrentFixture">GetCurrentFixture</a>: Get the
identity of the current fixture.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: Get the
identity of the current workpiece.
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>:
Get the identity of the as-is model for a workingstep.
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
Get the identity of the to-be model for a workinstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
Getthe identity of the removal model for a workinstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GetWorkpieceShapeNext></a>
<a name=GetWorkpieceShapeCount></a>GetWorkpieceShapeCount/Next()</h2>
<pre>
System::Int64 <b>GetWorkpieceShapeCount</b> (
	System::Int64 wp_id
	);

System::Int64 <b>GetWorkpieceShapeNext</b> (
	System::Int64 wp_id,
	System::Int64 index
	);
</pre>

<P>The <b>GetWorkpieceShapeCount()</b> function returns a count of the
number of geometry models in the assembly that defines a workpiece.

<P>The <b>GetWorkpieceShapeNext()</b> function iterates over the
geometry models in the assembly and returns the one at a given index.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD>The identity of a workpiece.
<DT>index: <DD> The position of the desired model.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Get the
identity of the current workpiece.
<li><a href="#GetCurrentFixture">GetCurrentFixture</a>: Get the
identity of the current fixture.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: Get the
identity of the current workpiece.
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>:
Get the identity of the as-is model for a workingstep.
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
Get the identity of the to-be model for a workinstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
Get the identity of the removal model for a workinstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity The wp_id does not identify a workpiece.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GoHome></a>GoHome()</h2>
<pre>
void <b>GoHome</b> (
	System::String^ label
	);
</pre>

<P>The <b>GoHome()</b> function adds a "Rapid home" NC function to the
current workplan. The rapid home function positions all machine axes
to the machine-defined home position in the absolute machine
coordinate system with a pre-defined sequence.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD> A label for the new function
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Stop">Stop</a>: Adds a stop to the current workplan.
<li><a href="#GoHomeAfter">GoHomeAfter</a>: Inserts the gohome at a
specific location in the program
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GoHomeAfter></a>GoHomeAfter()</h2>
<pre>
System::Int64 <b>GoHomeAfter</b> (
	System::String^ label,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>GoHomeAfter()</b> function adds a "rapid home" NC function
at chosen location in a workplan. The rapid home function positions
all machine axes to the machine-defined home position in the absolute
machine coordinate system with a pre-defined sequence.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label:<DD> A label for the new function
<DT>index: <DD> The position relative to the start of the workplan
where the workingstep is to be placed. If the index is less than 0
then it will be placed at the start of the workplan. If it is equal to
or greater than the size of the workplan then it will be placed after
the end. Otherwise it will be placed after the item in the current
position.
<DT>plan_id: <DD> The identifier of the workplan into which the
workingstep is to be inserted. See Seciton for a description of how to
use identifiers.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#GoHome">GoHome</a>:  Adds a GoHome at the current end
of the program.
<li><a href="#StopAfter">StopAfter</a>: Inserts a stop at a given
location in the program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GoToXYZ></a>GoToXYZ()</h2>
<pre>
void <b>GoToXYZ</b> (
	System::String^ label,
	double x,
	double y,
	double z
	);
</pre>

<P>The <b>GoToXYZ()</b> function adds a line to the current tool path.
The tool path is assumed to have a current point defined by the last
geometry item added to the path. The GOTO function moves the cutting
tool head to a new point that then becomes the current point for the
next geometry command.

<P>If the current workplan does not contain any workingsteps then one
will be created with the current tool. If the workingstep does not
contain any tool paths then one will be created. The toolpath will be
given the current feedrate and spindle speed.

<P>If this is the very first point after the tool has been changed and
if coordinates have been set using
the <a href="#FirstPathStartPoint">FirstPathStartPoint</a> function
then these coordinates will be used as the start point for the new
tool path and the new point will be added as the second point.

<P>If this is the very first point after a tool change and no point
has been defined using
the <a href="#FirstPathStartPoint">FirstPathStartPoint</a> function
then the given point will be repeated if necessary so that the new
tool path does not contain a single point (because this is illegal in
STEP-NC).

<P>If no feedrate has been defined then the feedrate will be zero. If
no spindle speed has been defined then the spindle speed will be zero.
If no tool has been loaded then the tool number will be zero.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD>A string argument that defines a name for the geometry
item. Typically this will be the empty string but it can be an
identifier to help another application find the item.
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the line.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#Arc">Arc</a>: This function adds arc segments to the
geometry.
<li><a href="#FirstPathStartPoint">FirstPathStartPoint</a>: Can be
used to define a start point for the tool path after a tool change.
<li><a href="#Feedrate">Feedrate</a>: This function sets the current
feedrate.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: This function sets the
current spindle speed.
<li><a href="#LoadTool">LoadTool</a>: This function sets the current
cutting tool.
<li><a href="#GoToXYZ_IJK">GoToXYZ_IJK</a>: Goto with a change of axes
as well as location.
<li><a href="#EditChangePoint">EditChangePoint</a>: Change the coordinates of a previoulsy
defined point.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=GoToXYZ_ABC></a>GoToXYZ_ABC()</h2>
<pre>
void <b>GoToXYZ_ABC</b> (
	System::String^ label,
	double x,
	double y,
	double z,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>GoToXYZ_ABC()</b> function is the same as
the <a href="#GoToXYZ">GoToXYZ</a> function but with a normal vector
defined for the point of contact between the cutting tool and the
workpiece.

<P>The contact normal is used to calculate a five-axis displacement
for the move by cutter compensation algorithms.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the line.
<DT>a, b, c: <DD> (i, j, k) components for the cutter compensation
direction.<p>
</DL>

<h3>Common Errors</h3>
<UL>
<li>The abc components should define a unit vector but the function
does not check.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=GoToXYZ_IJK></a>GoToXYZ_IJK()</h2>
<pre>
void <b>GoToXYZ_IJK</b> (
	System::String^ label,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k
	);
</pre>

<P>The <b>GoToXYZ_IJK()</b> function is the same as
the <a href="#GoToXYZ">GoToXYZ</a> function but with a new direction
of the tool axis.

<P>If the current tool path does not have an ijk component then a new
one is started. If the current tool path has ijk components and
the <a href="#GoToXYZ">GoToXYZ</a> function is subsequently used to
add a point then the ijk value of the previous point will be used for
the new point.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the line.
<DT>i, j, k: <DD>Components of the tool axis direction.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#MultaxOff">MultaxOff</a>: Stops the API from continuing
to include the last defined (i, j, k) coordinates in each tool path by
starting a new three axis tool path.
</UL>


<h3>Common Errors</h3>
<UL>
<li>The ijk components should define a unit vector but the function
does not check.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=GoToXYZ_IJK_ABC></a>GoToXYZ_IJK_ABC()</h2>
<pre>
void <b>GoToXYZ_IJK_ABC</b> (
	System::String^ label,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>GoToXYZ_IJK_ABC()</b> function is the same as
the <a href="#GoToXYZ">GoToXYZ</a> function but with a vector defined
for the direction of the tool axis, and a vector defined for normal of
the point of contact.

<P>If the current tool path does not have an abc component then a new
one is started. If the current tool path has abc components and the
next point does not then the current tool path is ended and a new one
is started.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the line.
<DT>i, j, k: <DD> Components of the tool axis direction.
<DT>a, b, c: <DD> (i, j, k) components for the cutter compensation
direction.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=GoToXYZ_IJK_REF_ABC></a>GoToXYZ_IJK_REF_ABC()</h2>
<pre>
void <b>GoToXYZ_IJK_REF_ABC</b> (
	System::String^ label,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>GoToXYZ_IJK_REF_ABC()</b> function is the same as
the <a href="#GoToXYZ">GoToXYZ</a> function but with a vector defined
for the direction of the tool axis, and a reference vector defined for
the X axis of the tool.  This is only useful for non-rotating tools
like CNC tape-laying heads.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD>The x, y, z coordinates of the end point of the line.
<DT>i, j, k: <DD> Components of the tool Z axis direction.
<DT>a, b, c: <DD> (i, j, k) components for the tool X axis direction.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=ImportFanuc></a>ImportFanuc()</h2>
<pre>
void <b>ImportFanuc</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ImportFanuc()</b> function reads a Fanuc G code file and
converts it contents to an AP-238 tool path.  By default a new
workingstep is created for each tool and spinde speed change and a new
tool path is created for each feed change.  The new workingsteps are
added to the current workplan.

<P>There are many flavors to ISO 6983 files. Please check the results
of this function and contact STEP Tools if there are any issues.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>file_name: <DD>File name for the file that contains the codes.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: Write the toolpaths in
a STEP-NC program into a Fanuc file.
<li><a href="#CamModeOn">CamModeOn</a>: Changes the default behavior
so that spindle speed changes only creates new tool paths.
<li><a href="#NestWorkplan">NestWorkplan</a>: Create a new workplan
for the new workingsteps and tool paths.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ImportHaas></a>ImportHaas()</h2>
<pre>
void <b>ImportHaas</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ImportHaas()</b> function reads a Haas G-code file.  See
the <a href="#ImportFanuc">ImportFanuc</a> function for details.


<!-- ================================ -->
<h2 class=rule>
<a name=ImportSiemens></a>ImportSiemens()</h2>
<pre>
void <b>ImportSiemens</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>ImportSiemens()</b> function reads a Siemens G-code file.
See the <a href="#ImportFanuc">ImportFanuc</a> function for details.


<!-- ================================ -->
<h2 class=rule>
<a name=ImportToolParametersFromSTRL></a>ImportToolParametersFromSTRL()</h2>
<pre>
System::Int64 <b>ImportToolParametersFromSTRL</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>ImportToolParametersFromSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ImportWorkingstepOperationFromSTRL></a>ImportWorkingstepOperationFromSTRL()</h2>
<pre>
System::Int64 <b>ImportWorkingstepOperationFromSTRL</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>ImportWorkingstepOperationFromSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ImportWorkingstepPaths></a>ImportWorkingstepPaths()</h2>
<pre>
void <b>ImportWorkingstepPaths</b> (
	System::Int64 ws_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ImportWorkingstepPaths()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ImportWorkpiecesFromSTRL></a>ImportWorkpiecesFromSTRL()</h2>
<pre>
System::Int64 <b>ImportWorkpiecesFromSTRL</b> (
	System::Int64 exe_id,
	[System::Runtime::InteropServices::Out] System::Int64 %asis_id
	);
</pre>

<P>The <b>ImportWorkpiecesFromSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ImportWorkplanFromFile></a>ImportWorkplanFromFile()</h2>
<pre>
void ImportWorkplanFromFile (
	System::Int64 wp_id,
	System::String^ file_name
	);
</pre>

<P>The <b>ImportWorkplanFromFile()</b> function reads the project
another file and adds all the executables in the main workplan of that
project to the end of a given workplan in the current file. The tools
of the other project are also added to the current project and given a
negative tool number to indicate that they are imported. If the same
project is imported twice then the same executables will be added
twice. No attempt is made to determine if the new tools are duplicates
of tools currently in the project.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD>Enclosing workplan to contain the imported process.
<DT>file_name: <DD>File name for the file that contains the codes.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#NestWorkplanAfter">NestWorkplanAfter</a>: Create a new
workplan for the inserted project.
<li><a href="#ChangeWorkingStepTool">ChangeWorkingStepTool</a>: Change
the tool of an imported workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ImportWorkplanFromSTRL></a>ImportWorkplanFromSTRL()</h2>
<pre>
System::Int64 <b>ImportWorkplanFromSTRL</b> (
	System::Int64 wp_id
	);
</pre>

<P>The <b>ImportWorkplanFromSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=Inches></a>Inches()</h2>
<pre>
void <b>Inches</b> ();
</pre>

<P>The <b>Inches()</b> function sets the internal unit for subsequent
measurement items to inches. Any tool path defined in an APT file or
an ISO 6983 file will be given this unit until it is reset by another
call.

<P>Unlike the <a href="#DefaultToInches">DefaultToInches</a> function,
the Inches function requires the units for subsequent items to be
inches. The DefaultToInches function defines a default for the APT
parsers when no other units have been defined.

<P>Internally the system stores data in inch units or millimeter
units. If an external file is found with other units then they are
converted to one of these units.

<h3>Related Functions</h3>
<UL>
<li><a href="#Millimeters">Millimeters</a>: Sets the unit for
subsequent toolpaths to millimeters.
<li><a href="#DefaultToInches">DefaultToInches</a>: Sets the unit to
inches if the system cannot find an appropriate unit elsewhere in the
system.
<li><a href="#DefaultToMillimeters">DefaultToMillimeters</a>: Sets the
unit to millimeters if the system cannot find an appropriate unit
elsewhere in the system.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.

</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=IndexTable></a>IndexTable()</h2>
<pre>
void <b>IndexTable</b> (
	System::String^ label,
	System::Int64 index_value
	);
</pre>

<P>The <b>IndexTable()</b> function adds an NC operation to advance
the machine table.  In CNC programs an Index Table function tells the
CNC control to rotate an index table to a new position so that another
part of the workpiece can be machined.

<P>The index table function is highly machine dependent because the
meaning of the index value depends on the machine tool. Like the
Extended NC function, this function should be avoided whenever
possible.
The <a href="#WorkplanWorkpiecePlacementAdd">WorkplanWorkpiecePlacementAdd</a>
function defines a machine independent way to change the setup.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD> An optional label for the new function.
<DT>index_value: <DD> The required position of the index.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#IndexTableAfter">IndexTableAfter</a>: Inserts the index
table function into a given location in the STEP-NC program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=IndexTableAfter></a>IndexTableAfter()</h2>
<pre>
System::Int64 <b>IndexTableAfter</b> (
	System::String^ label,
	System::Int64 index_value,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>IndexTableAfter()</b> function inserts an Index table
function into a given location in the STEP-NC program.   See
<a href="#IndexTable">IndexTable</a> for more discussion.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>label: <DD> An optional label for the new function.
<DT>index_value: <DD> The required position of the table index.
<DT>index: <DD> The desired position for the function in the workplan.
<DT>plan_id: <DD> The identity of the workplan that is to contain the
new function. See Section for some important notes on how to use
identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#IndexTable">IndexTable</a>: Adds the index table
function to the current end of the STEP-NC program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=IsToolDefined></a>IsToolDefined()</h2>
<pre>
System::Boolean <b>IsToolDefined</b> (
	System::Int64 tool_number
	);
</pre>

<P>The <b>IsToolDefined()</b> function returns a flag indicating if a
tool with the given tool number exists in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tool_number: <DD>The number of the tool whose existence is to be
tested
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#LoadTool">LoadTool</a>: Loads a tool using the tool
number. IsToolDefined can be used to prevent this function issuing an
error message if the tool does not exist.
<li><a href="#DefineTool">DefineTool</a>: Function used to define a
tool.
<li><a href="#SELCTLTool">SELCTLTool</a>: Function used to set the
tool number of a tool
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=Left></a>Left()</h2>
<pre>
void <b>Left</b> ();
</pre>

<P>The <b>Left()</b> function implements the simple case for cutter
contact machining where the workpiece is on the left side of the tool
as seen from the perspective of someone walking in the direction of
the tool.

<P>After the function has been set an appropriate ABC contact
vector is generated for each new geometry item added to the toolpath


<h3>Related Functions</h3>
<UL>
<li><a href="#Right">Right</a>: Defines contact on the right hand side
of the tool.
<li><a href="#GoToXYZ">GoToXYZ</a>: Defines points that will use the
contact point.
<li><a href="#CenterOn">CenterOn</a>: Turns contact mode off.
Subsequent tool paths will not be given a contact normal.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=LoadTool></a>LoadTool()</h2>
<pre>
void <b>LoadTool</b> (
	System::Int64 tool_number
	);
</pre>

<P>The <b>LoadTool()</b> function

The new tool becomes the current tool for the next
workingstep. If a workingstep is open then they it is closed and a new one is
created for the next geometry item. This happens even if the new tool is the
same as the last one.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>tool_number: <DD> The number of the tool that is to be the tool
for the new workingstep
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#IsToolDefined">IsToolDefined</a>: Tests to see if the
tool exist and thereby prevents one of the possible errors.
<li><a href="#DefineTool">DefineTool</a>: Function used to define the
parameters for a tool.
<li><a href="#SELCTLTool">SELCTLTool</a>: Function used to set the
tool number of a tool.
<li><a href="#ToolGeometry">ToolGeometry</a>: Defines AP-203 geometry
for the tool so that it can be seen in a simulation.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>No tool: There is no tool in the data with this number.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=LoadToolWithLength></a>LoadToolWithLength()</h2>
<pre>
void <b>LoadToolWithLength</b> (
	System::Int64 tool_number,
	double length
	);
</pre>

<P>The <b>LoadToolWithLength()</b> function sets the functional length
of the tool before making it the current tool for the next
workingstep.

<h3>Arguments</h3>
<DL class=termdefs>
<li>tool_number:<DD> The number of the tool that is to be the tool for
the new workingstep
<DT>length: <DD>The length of the tool in the current units.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#LoadTool">LoadTool</a>: Load a tool without setting its
length.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>No tool: There is no tool in the data with this number.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=MergeFollowingWorkingstep></a>MergeFollowingWorkingstep()</h2>
<pre>
void <b>MergeFollowingWorkingstep</b> (
	System::Int64 wp_id,
	System::Int64 index
	);
</pre>

<P>The <b>MergeFollowingWorkingstep()</b> function merges two
consecutive workingsteps if they use the same tool. After the merger
the second workingstep is deleted.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD> The workplan containing the workingstep
<DT>index: <DD>The position of the first workingstep
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#MergeWorkingstep">MergeWorkingstep</a>: Merge any two
workingsteps.
<li><a href="#MergeFollowingWorkingstepAll">MergeFollowingWorkingstepAll</a>:
Merge a list of workingsteps.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The first argument does not identify a workplan.
<li>Bad index: The second argument does not identify a workingstep in
the workplan or it is at the end of the workplan
<li>Wrong tool:  The two workingsteps do not use the same tool.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=MergeFollowingWorkingstepAll></a>MergeFollowingWorkingstepAll()</h2>
<pre>
void <b>MergeFollowingWorkingstepAll</b> (
	System::Int64 wp_id,
	System::Int64 index
	);
</pre>

<P>The <b>MergeFollowingWorkingstepAll()</b> function merges a list of
consecutive workingsteps until one is found that does not use the same
tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD>The workplan containing the workingstep
<DT>index: <DD> The position of the first workingstep
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#MergeWorkingstep">MergeWorkingstep</a>: Merge any two
workingsteps.
<li><a href="#MergeFollowingWorkingstep">MergeFollowingWorkingstep</a>:
Merge two consecutive workingsteps.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The first argument does not identify a workplan.
<li>Bad index: The second argument does not identify a workingstep in
the workplan
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=MergeWorkingstep></a>MergeWorkingstep()</h2>
<pre>
void <b>MergeWorkingstep</b> (
	System::Int64 ws1_id,
	System::Int64 ws2_id
	);
</pre>

<P>The <b>MergeWorkingstep()</b> function merges two workingsteps if
they use the same tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws1_id: <DD>The workingstep to contain all the data
<DT>ws2_id: <DD>The workingstep to be merged and deleted
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#MergeFollowingWorkingstep">MergeFollowingWorkingstep</a>:
Merge two consecutive workingsteps.
<li><a href="#MergeFollowingWorkingstepAll">MergeFollowingWorkingstepAll</a>:
Merge a list of workingsteps.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The first or second argument does not identify a
workingstep.
<li>Wrong tool: The two workingsteps do not use the same tool.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Millimeters></a>Millimeters()</h2>
<pre>
void <b>Millimeters</b> ();
</pre>

<P>See <a href="#Inches">Inches</a>.



<!-- ================================ -->
<a name=MultaxOn></a>
<h2 class=rule>
<a name=MultaxOff></a>MultaxOn/Off()</h2>
<pre>
void <b>MultaxOn</b> ();
void <b>MultaxOff</b> ();
</pre>

<P>The <b>MultaxOn()</b> function currently has no effect. In the
future it might be used to force the inclusion of i, j, k coordinates
in the tool path. The current semantics is for i, j, k to be included
in a toolpath only after a point has been defined using
the <a href="#GoToXYZ_IJK">GoToXYZ_IJK</a>
or <a href="#GoToXYZ_IJK_ABC">GoToXYZ_IJK_ABC</a>
functions.

<P>The <b>MultaxOff()</b> function turns i, j, k tool axis generation
off. After a point has been defined using
the <a href="#GoToXYZ_IJK">GoToXYZ_IJK</a> function the STEP-NC API
assumes that all subsequent points should include tool axis data. The
MultaxOff function stops this behavior.


<!-- ================================ -->
<h2 class=rule>
<a name=NestSelectiveAfter></a>NestSelectiveAfter()</h2>
<pre>
System::Int64 NestSelectiveAfter (
	System::String^ sel_name,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>NestSelectiveAfter()</b> function creates a selective and
inserts it into a workplan (or another selective) in the same way as
the <a href="#NestWorkplan">NestWorkplan</a> function.  This function
returns the identifier of the new Selective.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>name: <DD> The name of the new selective. We recommend giving
every workplan a meaningful name.
<DT>index: <DD> The position where the new workplan is to be inserted
in the workplan or selective identified by the plan_id argument. The
first position is 0 and the last position is the current size of the
workplan - 1. The new item is inserted after the given index
position. If the index is greater than current size &ndash; 1 then the
new workplan is inserted at the end of the old plan. If the index is
less than 0 then the new workplan is inserted at the start of the old
workplan.
<DT>plan_id: <DD> The id of the workplan or selective that is going to
contain the new selective.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=NestWorkplan></a>NestWorkplan()</h2>
<pre>
void <b>NestWorkplan</b> (
	System::String^ plan_name
	);
</pre>

<P>The <b>NestWorkplan()</b> function creates a new workplan and makes
it the current workplan for all subsequent operations.  This function
returns the identifier of the new Workplan.

<P>The new workplan is put into the old workplan. The old workplan is
kept on a stack so that it can become the current workplan again when
this workplan is ended. See <a href="#EndWorkplan">EndWorkplan</a> for
details on how to end a workplan.

<P>The workplan is the basic data structure of a STEP-NC program. A
workplan describes a sequence of workingsteps, NC functions and other
workplans that are to be executed in order.  Every STEP-NC program has
a special workplan called the main_workplan that defines the start of
the program. The NestWorkplan function allows other workplans to be
created.

<P>Note: NestWorkplan is meant to be designed to be used by APT
translators. The NestWorkplanAfter functions are designed to be used
by data editors. There is no NestSelective function because this type
of functionality is not supported by current APT systems.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>name
workplan a meaningful name because they are seen by users.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#EndWorkplan">EndWorkplan</a>: <DD> This function ends
the current workplan.
<li><a href="#GetCurrentWorkplan">GetCurrentWorkplan</a>: <DD> This
function returns the internal identifier of the current workplan.
<li><a href="#NestWorkplanAfter">NestWorkplanAfter</a>: <DD> This
function allows a new workplan to be placed at an arbitrary location
in the program.
<li><a href="#NestSelectiveAfter">NestSelectiveAfter</a>: <DD> This
function allows a new selectve to be placed at an arbitrary location
in the program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=NestWorkplanAfter></a>NestWorkplanAfter()</h2>
<pre>
System::Int64 <b>NestWorkplanAfter</b> (
	System::String^ plan_name,
	System::Int64 index,
	System::Int64 wp_id
	);
</pre>

<P>The <b>NestWorkplanAfter()</b> function operates in the same way as
the <a href="#NestWorkplan">NestWorkplan</a> function and allows the
position of the new workplan to be selected by the user.  This
function returns the identifier of the new Workplan.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>name: <DD> The name of the new workplan. We recommend giving every
workplan a meaningful name.
<DT>index: <DD> The position where the new workplan is to be inserted
in the workplan (which may be a selective) identified by the plan_id
argument. The first position is 0 and the last position is the current
size of the workplan - 1. The new item is inserted after the given
index position. If the index is greater than current size &ndash; 1
then the new workplan is inserted at the end of the old plan. If the
index is less than 0 then the new workplan is inserted at the start of
the old workplan.
<DT>plan_id: <DD> The id of the workplan or selective that is going to
contain the new workplan.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=NewProject></a>NewProject()</h2>
<pre>
void <b>NewProject</b> (
	System::String^ project_name
	);
</pre>

<P>The <b>NewProject()</b> function creates a new STEP-NC program with
an empty workpiece and an empty main workplan. The workplan is given
the name &ldquo;main workplan&rdquo; and its workpiece is given the
name &ldquo;unnamed workpiece&rdquo;. The new project can then be
populated with data taken from STEP CAD files, APT files and other data
sources.

<P>The default feeds and speeds for the new project will be 0. The
default tool number for the first tool will be 0.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>project_name: <DD> The name to be used for the project. If the new
project has to be saved to a file and no other file name is given then
the project name will be used as the file name.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#Open238">OpenProject</a>: Starts a new project by reading an
AP-238 file.
<li><a href="#SaveAsModules">SaveAsModules</a>: Stores the current
project in an AP-238 XML file.
<li><a href="#SaveAsPart21">SaveAsPart21</a>: Stores the current
project in an AP-238 ASCII file.
<li><a href="#NewProjectWithCCandWP">NewProjectWithCCandWP</a>: Sets
the name of the main workplan when the new project is created.
<li><a href="#GoToXYZ">GoToXYZ</a>: Start making tool paths in the new
project.
</UL>

<h3>Common Errors</h3>
<UL>
<p>None but &ldquo;project not open&rdquo; is the most common error
for all of the other functions and this function fixes that problem by
creating an empty project.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=NewProjectWithCCandWP></a>NewProjectWithCCandWP()</h2>
<pre>
void <b>NewProjectWithCCandWP</b> (
	System::String^ project_name,
	System::Int64 conformance_class,
	System::String^ top_workplan_name
	);
</pre>

<P>The <b>NewProjectWithCCandWP()</b> function is a version of
the <a href="#NewProject">NewProject</a> function allows the new main
workplan in the new project to be given a name.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>project_name:  <DD> The
name to be used for the project. If the new project has to be saved to a file
and no other file name is given then the project name will be used as the file
name.
<DT>conformance_class: <DD>1, 2, 3 or 4 for the four conformance
classes allowed by AP-238. This value is not currently
used.
<DT>top_workplan_name: <DD>The name for the main workplan of the new
project.
</DL>

<P>Currently the conformance class is not used anywhere in the API. In
the future it may be used to restrict the kinds of data that can be
created by an application. The full details about what is allowed in
the different conformance classes are described in the AP-238
standard. The following is a summary.
<UL>
<li>Conformance Class 1: indicates that the program
contains tool path data only.

<li>Conformance Class 2: indicates that the program
contains part geometry as well as tool path data.

<li>Conformance Class 3:   indicates that the program
contains drilling, milling, turning operations described parametrically as well
as the data from conformance classes 1 and 2.

<li>Conformance Class 4: indicates that the program contains everything
defined in AP-238 including geometric features, dimensions and
tolerances.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Open224></a>Open224()</h2>
<pre>
void <b>Open224</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>Open224()</b> function reads an AP-224 file and uses the
workpiece and rawpiece data in that file to create an AP-238 project
with that workpiece and rawpiece. The AP-238 project will have an
empty workplan.

<P>AP-224 is the STEP protocol for manufacturing features.
Therefore, the new project will have a workpiece that contains features.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File_name: <DD>The name of the file that contains the AP-224 data.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Open238">OpenProject</a>: Starts a new project by reading an
AP-238 file.
<li><a href="#SaveAsModules">SaveAsModules</a>: Stores the current
project in an AP-238 XML file.
<li><a href="#SaveAsPart21">SaveAsPart21</a>: Stores the current
project in an AP-238 ASCII file.
<li><a href="#Open224andMakeWorkingSteps">Open224andMakeWorkingSteps</a>:
Create a workingstep for each feature in the AP-224 file.
</UL>

<h3>Common Errors</h3>
<UL>
<li>File not found.  The file name may use the common syntax to define
  directories and network locations.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Open224andMakeWorkingSteps></a>Open224andMakeWorkingSteps()</h2>
<pre>
void <b>Open224andMakeWorkingSteps</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>Open224andMakeWorkingSteps()</b> function is a version of
the <a href="#Open224">Open224</a> function creates a workingstep for
each feature in the AP-224 file. This makes the AP-224 data easier to
browse, but it is unlikely to be a satisfactory organization if the
intention is to develop an AP-238 file for machining the data because
the correspondence between AP-224 features and machining operations is
rarely one to one.

<P>Arguments are the same as <a href="#Open224">Open224</a>



<!-- ================================ -->
<h2 class=rule>
<a name=Open238></a>OpenProject()/OpenSTEPNC()/Open238()</h2>
<pre>
void <b>OpenProject</b> (
	System::String^ file_name
	);
</pre>

<pre>
void <b>OpenSTEPNC</b> (
	System::String^ file_name
	);
</pre>

<pre>
void <b>Open238</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>OpenProject()</b> function reads a STEP-NC file.

<P>If your plan is to navigate and process the data in the project
then the <A href="Finder.html">Finder</A> object has many more
functions for finding data than APT. If your plan is to add data to
the file then the <A href="Process.html">Process</A> object has
functionality for modifying the
process, and the <A href="Tolerance.html">Tolerance</A> object has
functionality for defining design
constraints. Process and Tolerance use APT to read their data.

<P><b>Open238()</b> is a legacy name from early versions of the system.

<P><b>OpenSTEPNC()</b> is an alternate name provided to help early stage
users find basic functionality.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File_name: <DD>The name of the file that contains the STEP-NC data.

</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SaveAsModules">SaveAsModules</a>: Stores the current
project STEP-NC file containing lots of system generated comments.
<li><a href="#SaveAsPart21">SaveAsPart21</a>: Stores the current
project in a file without comments.
</UL>

<h3>Common Errors</h3>
<UL>
<li>File not found.  The file name may use the common syntax to define
  directories and network locations.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=OpenCheckSTRL></a>OpenCheckSTRL()</h2>
<pre>
System::Int64 <b>OpenCheckSTRL</b> (
	System::String^ strl
	);
</pre>

<P>The <b>OpenCheckSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=OpenSTEP></a>OpenSTEP()</h2>
<div class="tabview">
<pre class=".net">
void <b>OpenSTEP</b> (
	System::String^ file_name
	);
</pre>
<pre class="node.js">
void <b>OpenSTEP</b> (
	string file_name
	);
</pre>
<pre class="C++">
RoseBoolean <b>read_203_file</b> (
	char * file_name
	);
</pre>
</div>

<P>The <b>OpenSTEP()</b> function opens a STEP file for viewing and editing.
Tolerances and other GD&T information may be defined for the file using the
API of the tolerance object.

<h3>Related Functions</h3>
<UL>
<li><a href="#Open238">OpenProject</a>: Opens a STEP-NC file for viewing
and editing.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=OpenUsingSTRL></a>OpenUsingSTRL()</h2>
<pre>
void <b>OpenUsingSTRL</b> (
	System::String^ strl
	);
</pre>

<P>The <b>OpenUsingSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=OptionalStop></a>OptionalStop()</h2>
<pre>
void <b>OptionalStop</b> (
	System::String^ label
	);
</pre>

<P>The <b>OptionalStop()</b> function adds the Optional Stop NC
function to the current workplan. The Optional Stop function indicates
to the operator that the program can be stopped. In many situations it
is best not to include this function in a program but instead allow
the user to decide if an optional stop should be defined at the end of
each workingstep during code conversion.

<P>If a workingstep and toolpath is open when an NC function is added
then that workingstep and toolpath will be ended.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD>A label that can be used to identify the optional stop.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Stop">Stop</a>: Adds a non-optional stop to the STEP-NC
program.
<li><a href="#SetCNCexportInsertStopAfterWorkings">SetCNCexportInsertStopAfterWorkingstep</a>:
Tells the STEP-NC to ISO 6983 converter functions (ExportAsFanuc etc)
to put a Stop at the end of every workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=OptionalStopAfter></a>OptionalStopAfter()</h2>
<pre>
System::Int64 <b>OptionalStopAfter</b> (
	System::String^ label,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>OptionalStopAfter()</b> function adds the Optional Stop NC
function to a given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD> A label for the new function
<DT>Index: <DD> The position relative to the start of the workplan
where the workingstep is to be placed. If the index is less than 0
then it will be placed at the start of the workplan. If it is equal to
or greater than the size of the workplan then it will be placed after
the end. Otherwise it will be placed after the item in the current
position.
<DT>Plan_id: <DD> The identifier of the workplan into which the
workingstep is to be inserted. See Seciton for a description of how to
use identifiers.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#OptionalStop">OptionalStop</a>: Add an optional stop to
the current end of the program.
<li><a href="#StopAfter">StopAfter</a>: Adds a non-optional stop to
the STEP-NC program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=PartNo></a>PartNo()</h2>
<pre>
void <b>PartNo</b> (
	System::String^ partname
	);
</pre>

<P>The <b>PartNo()</b> function sets the name of the workpiece. It
does not change any other attributes of the workpiece so if the
geometry of the workpiece has been defined using
the <a href="#Workpiece">Workpiece</a> function then that geometry
will continue to be used but with the new workpiece name.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>PartName: <DD>The name to be given to the Workpiece.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Workpiece">Workpiece</a>: This function defines a name
for the workpiece and gives it a geometry definition.
</UL>

<h3>Common Errors</h3>
<UL>
<li>There are no errors because the function creates a new default
project called &ldquo;default project&rdquo; if no project is
currently defined.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=PPrint></a>PPrint()</h2>
<pre>
void <b>PPrint</b> (
	System::String^ label,
	System::String^ message
	);
</pre>

<P>The <b>PPrint()</b> function defines an NC function display message
that is to be shown to the user during the execution of the STEP-NC
program. If a workingstep and toolpath is open when an NC function is
added then that workingstep and toolpath will be ended.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD>A label that can be used to identify the display
message.
<DT>Message: <DD>The value of the message as a text string
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PPrintAfter">PPrintAfter</a>: Inserts the display
function into a given location in the STEP-NC program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=PPrintAfter></a>PPrintAfter()</h2>
<pre>
System::Int64 <b>PPrintAfter</b> (
	System::String^ label,
	System::String^ message,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>PPrintAfter()</b> function adds an NC function display
message to a given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD> A label for the new function
<DT>Message: <DD>The value of the message as a text string
<DT>Index: <DD>The position relative to the start of the workplan
where the workingstep is to be placed. If the index is less than 0
then it will be placed at the start of the workplan. If it is equal to
or greater than the size of the workplan then it will be placed after
the end. Otherwise it will be placed after the item in the current
position.
<DT>Plan_id: <DD> The identifier of the workplan into which the
workingstep is to be inserted. See Seciton for a description of how to
use identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PPrint">PPrint</a>: Adds a display function to the
current end of the program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=ProbeOperation></a>ProbeOperation()</h2>
<pre>
void <b>ProbeOperation</b> (
	double x,
	double y,
	double z,
	double i,
	double j,
	double k
	);
</pre>

<P>The <b>ProbeOperation()</b> function adds a workpiece probing
operation to the current workplan.
The <a href="Tolerance.html">Tolerance</a> object contains functions
that can both define tolerances and create workplans for testing those
tolerances. This function creates a simple probing operation at the
given location on the assumption that another system has determined
that this is a good location for probing.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD> Coordinates for the probing operation.
<DT>i, j, k: <DD> Direction for the probing operation Z axis
<DT>a, b, c:<DD> Direction for the probing operation X axis
</DL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=PutWorkpiecePlacement></a>PutWorkpiecePlacement()</h2>
<pre>
void <b>PutWorkpiecePlacement</b> (
	System::Int64 wp_id,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>PutWorkpiecePlacement()</b> function updates the location of
a workpiece.  CAD and CAM systems typically use different coordinate
systems. In CAD a part is positioned and oriented in the coordinates
it will be given in the final product. In CAM a part is positioned and
oriented so that the machining will start in the middle of the top of
the rawpiece.

<P>In order to detect collisions between the tool and the workpiece,
the position and orientation of the workpiece has to be changed to
conform to the coordinates chosen for the tool paths.

<P>In STEP, geometry is positioned and oriented using axis
placements. To place the part, the user needs to describe the
coordinates and orientations that must be given to the origin and axes
(Z and X) of the workpiece in the coordinate system of the tool paths.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>id: <DD> The identity of the model whose placement is to be
changed. The model can be any workpiece, rawpiece, fixture, in-process
model or tool .
<DT>x, y, z: <DD> New coordinates for the model origin.
<DT>i, j, k: <DD> New direction for the model Z axis
<DT>a, b, c <DD> New direction for the model X axis
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GetWorkpiecePlacement">GetPlacement</a>: Get the current
placement values for the workpiece.
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Get the
identity of the current workpiece so that its placement can be
changed.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: Get the
identity of the current rawpiece so that its placement can be changed.
<li><a href="#GetCurrentFixture">GetCurrentFixture</a>: Get the
identity of the current fixture so that its placement can be changed.
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>:
Get the identity of the as-is model for a workingstep.
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
Get the identity of the to-be model for a workinstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
Get the identity of the removal model for a
workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=Rapid></a>Rapid()</h2>
<pre>
void <b>Rapid</b> ();
</pre>

<P>The <b>Rapid()</b> function sets the feedrate to rapid for all
subsequent tool path moves until changed by a call to the Feedrate
function.  Note that this is different to the APT semantics which
define the rapid for the next move only.

<h3>Related Functions</h3>
<UL>
<li><a href="#Arc">Arc</a>: This function adds arc segments to the
geometry and is not allowed for rapid moves.
<li><a href="#GoToXYZ">GoToXYZ</a>: This function adds line segments
to the geometry and they will be rapid moves if the STEP-NC API is
currently in rapid mode.
<li><a href="#Feedrate">Feedrate</a>: This function defines the
current feedrate and cancels the rapid.
<li><a href="#FeedrateCSS">FeedrateCSS</a>: This function defines the
current feedrate for turning machines and cancels the rapid.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>




<!-- ================================ -->
<h2 class=rule>
<a name=Rawpiece></a>Rawpiece()</h2>
<pre>
void <b>Rawpiece</b> (
	System::String^ filename
	);
</pre>

<P>The <b>Rawpiece()</b> function defines the geometry of the rawpiece
from an STEP CAD file. The function assumes that all of the geometry in
the file is to make up the rawpiece. Any STEP file can be used to
define the geometry provided it is compatible with AP-203. If the file
is an AP-203 Edition 2 file then the geometry may include dimensions
and tolerances. See the <a href="Tolerance.html">Tolerance</a> object
for more information on how tolerances are processed in the API.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the STEP file that defines the
rawpiece.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: This
function changes the placement of the rawpiece so that it can be
positioned and oriented correctly within the context of the tool
paths.
<li><a href="#ExportWorkpiece">ExportWorkpiece</a>: This function
exports an STEP CAD file describing any workpiece including the
rawpiece.
<li><a href="#Workpiece">Workpiece</a>: Performs the same function as
rawpiece but for the workpiece
<li><a href="#Fixture">Fixture</a>: Performs the same function as
rawpiece but for the fixture.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: Returns the
id of the current rawpiece or null (0).
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad File: The API was unable to open a file with the given name or
it was not a valid STEP file.
<li>Bad name: The rawpiece cannot have the same name as the project.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=RawpieceOfWorkpiece></a>RawpieceOfWorkpiece()</h2>
<pre>
void <b>RawpieceOfWorkpiece</b> (
	System::Int64 rp_id,
	System::Int64 wp_id
	);
</pre>

<P>The <b>RawpieceOfWorkpiece()</b> function

The rawpiece of a workpiece defines the geometry of the
part before the machining began.  The function returns the identity of the rawpiece or 0 if no rawpiece has been
defined.
In most STEP-NC programs there is one
workpiece and one rawpiece. In more complex programs there can be many
workpieces in many setups and each workpiece may have a rawpiece defined. The
RawpieceOfWorkpiece function finds the rawpiece defined for a given workpiece.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD> The identity of any workpiece in the STEP-NC program
including workpieces that are being used define rawpieces, as-is,
to-be or removal geometries for a workingstep.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Get the
identity of the current workpiece so that its placement can be
changed.
<li><a href="#GetCurrentRawpiece">GetCurrentRawpiece</a>: Get the
identity of the current rawpiece so that its placement can be changed.
<li><a href="#GetCurrentFixture">GetCurrentFixture</a>: Get the
identity of the current fixture so that its placement can be changed.
<li><a href="#GetExecutableWorkpieceAsIs">GetExecutableWorkpieceAsIs</a>:
Get the identity of the as-is model for a workingstep.
<li><a href="#GetExecutableWorkpieceToBe">GetExecutableWorkpieceToBe</a>:
Get the identity of the to-be model for a workinstep.
<li><a href="#GetExecutableWorkpieceRemoval">GetExecutableWorkpieceRemoval</a>:
Get the identity of the removal model for a workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see the NewProject
function.
<li>Bad identity: The wp_id does not identify a workpiece.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=ReadCatiaAPTclfile></a>ReadCatiaAPTclfile()</h2>
<pre>
void <b>ReadCatiaAPTclfile</b> (
	System::String^ filename
	);
</pre>

<P>The <b>ReadCatiaAPTclfile()</b> function reads an APT CL file as
produced by the CATIA CAD/CAM system and converts the tool paths and
operations in that data into AP-238 tool paths and operations.

<P>APT CL as defined by the CATIA system is a binary data format with
many internal complexities. The ReadCatiaAPTclfile function has been
extensively tested in many projects but every enterprise seems to use
these files slightly differently so some customization work may be
necessary when the reader is applied to the data of a new organization.

<P>The CATIA APTCL reader calls other functions in the ATPSTEPMaker to
make the objects required to represent the APT program as STEP-NC. The
reader consists of a parser and you can make your
own APT readers by calling the same functionality. There are several
other APT readers in the API that read the APT made by other systems.

<P>A typical data assembly application will create a new project and
then read tool path data from one or more APT files. Each read adds
data to the project. In order to keep the project well organized it
can be a good idea to put the data from each file into its own
Workplan using the <a href="#NestWorkplan">NestWorkplan</a> function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the APT cl file.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ReadCatiaAPTclfile">ReadCatiaAptPlateClfile</a>: This
function reads CATIA APT files describing plate cutting
operations. These APT files have an ASCII format.
<li><a href="#ReadUGSAPTclfile">ReadUGSAPTclfile</a>: This function
reads APT files produced by the UGS system.
<li><a href="#ReadProeAPTclfile">ReadProeAPTclfile</a>: This function
reads APT files produced by the Pro/Engineer system.
<li><a href="#ReadMax5APTclfile">ReadMax5APTclfile</a>: This function
reads APT files produced by the Max 5 CAM system.
<li><a href="#DefaultToInches">DefaultToInches</a>: This function sets
the default unit to inches. (Some APT file do not describe any units.)
<li><a href="#DefaultToMillimeters">DefaultToMillimeters</a>: Sets the
default unit to millimeters.
<li><a href="#NewProject">NewProject</a>: Starts a new project
<li><a href="#NestWorkplan">NestWorkplan</a>: Starts a new nested
workplan.
<li><a href="#EndWorkplan">EndWorkplan</a>: Ends a nested workplan and
returns to the previous workplan
<li><a href="#DeleteAllUnusedTools">DeleteAllUnusedTools</a>: If your program
reads two CL files then the second one will reuse the tools of the first
if they have the same tool number, but not before creating a dummy unused
tool record. This function will delete those unused tools.

</UL>

<h3>Common Errors</h3>
<UL>
<li>Bad File: The API was unable to open a file with the given name or
it was not a valid APT CL file.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=ReadCatiaAptPlateClfile></a>ReadCatiaAptPlateClfile()</h2>
<pre>
void <b>ReadCatiaAptPlateClfile</b> (
	System::String^ filename
	);
</pre>

<P>The <b>ReadCatiaAptPlateClfile()</b> function reads an ASCII APT CL
 file produced by the CATIA CAD/CAM system for plate cutting. Plate
 cutting APT files include special cycles for controlling the cutting
 and marking.  Data created using this translator can be sent to plate
 cutting machines using the ESAB converter.



<!-- ================================ -->
<h2 class=rule>
<a name=ReadMax5APTclfile></a>ReadMax5APTclfile()</h2>
<pre>
void <b>ReadMax5APTclfile</b> (
	System::String^ filename,
	System::Int64 tool_num
	);
</pre>

<P>The <b>ReadMax5APTclfile()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ReadProeAPTclfile></a>ReadProeAPTclfile()</h2>
<pre>
void <b>ReadProeAPTclfile</b> (
	System::String^ filename
	);
</pre>

<P>The <b>ReadProeAPTclfile()</b> function reads an APT CL file as
produced by the Pro/Engineer CAD/CAM system and converts the tool
paths and operations in that data into AP-238 tool paths and
operations. Pro/E APT CL files have an ASCII data format and are
usually stored in files with a &ldquo;.ncl&rdquo; suffix.



<!-- ================================ -->
<h2 class=rule>
<a name=ReadUgsAPTclfile></a>ReadUgsAPTclfile()</h2>
<pre>
void <b>ReadUgsAPTclfile</b> (
	System::String^ filename
	);
</pre>

<P>The <b>ReadUgsAPTclfile()</b> function reads an APT CL file as
produced by the Siemens UGS CAD/CAM system and converts the tool paths
and operations in that data into AP-238 tool paths and operations. UGS
APT CL files have an ASCII data format and are usually stored in files
with a &ldquo;.cls&rdquo; suffix.


<!-- ================================ -->
<h2 class=rule>
<a name=ReplaceMax5APTclfile></a>ReplaceMax5APTclfile()</h2>
<pre>
void <b>ReplaceMax5APTclfile</b> (
	System::String^ filename,
	System::Int64 ws_id
	);
</pre>

<P>The <b>ReplaceMax5APTclfile()</b> function reads an APT CL file as
produced by the Max5 CAM system and converts the tool paths and
operations in that data into AP-238 tool paths and operations. Max5 is
a CAM system that specializes in the definition of CNC programs for
machining impellers. Max5 APT files are similar to UGS APT. They do
not use any particular file suffix. They also expect the tool number
to be defined before parsing so a tool number parameter is required as
an argument for the parser.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the APT file.
<DT>Tool number: <DD>Tool number for this file.
</DL>


<!-- ================================ -->
<h2 class=rule>
<a name=Reset></a>Reset()</h2>
<pre>
void <b>Reset</b> ();
</pre>

<P>The <b>Reset()</b> function resets the APT object to its initial
state. A closely related function
called <a href="#Shutdown">Shutdown</a> also resets the object but it
deletes all of the data in the object as well. Reset does not delete
the data and this can be important in applications where multiple
objects are sharing data in the same underlying file in the ROSE data
management system. In this case all but the last object should execute
a reset and after they have finished the last
should <a href="#Shutdown">Shutdown</a>.

<P>Reset and <a href="#Shutdown">Shutdown</a> should only be used by
advanced applications that are running a long time and need to
conserve data resources.

<h3>Related Functions</h3>
<UL>
<li><a href="#Shutdown">Shutdown</a>: Deletes all the data in the
object as well as setting it back to its initial state.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=RetractPlane></a>RetractPlane()</h2>
<pre>
void <b>RetractPlane</b> (
	double z_value
	);
</pre>

<P>The <b>RetractPlane()</b> function defines a safe distance from the
surface being machined for rapid movements during an operation. If an
application is generating its own tool paths for an operation then it
can use the retract plane as the safe distance for rapid movement
during the operation.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>z_value: <DD>The retract plane is defined to be at the given
distance from the surface being machined. The direction of the
distance depends on the current normal of the surface when the retract
is executed.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ClearancePlane">ClearancePlane</a>: This function
defines security plane for rapid moves between operations.
<li> <p>The functions in the Process object that create the
different types of milling, drilling and turning objects use the retract
distance.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>The API does not contain functionality to check for rapid tool
movements below the retract plane.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=ReuseFixtureReference></a>ReuseFixtureReference()</h2>
<pre>
void <b>ReuseFixtureReference</b> (
	System::Int64 plan_id,
	System::Int64 resue_plan_id
	);
</pre>

<P>The <b>ReuseFixtureReference()</b> function explitly resuses the fixture
of another workplan in this workplan. This is useful when the fixture has
already been defined and it cannot be inherited from a workplan that is
a common parent. After the reuse the existing fixture of the workplan will
be orphaned and may be deleted if it is not being used by any other workplan.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan that is to be given another workplans fixture.
<DT>ruse_plan_id: <DD> The identity of a workplan that has a fixture explicitly defined.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="Finder.html#IsWorkplanWithSetupAndFixture">IsWorkplanWithSetupAndFixture</a>: Finder function that
returns true (1) if the workplan has a fixture defined.
<li><a href="#DeleteWorkpiece">DeleteWorkpiece</a>: Deletes a workpiece by removing
all its data from the project.
<li><a href="#Fixture">Fixture</a>: Define a fixture using a CAD file.
<li><a href="#DeleteFixture">DeleteFixture</a>: Delete the fixture reference of a
workplan. 


</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Right></a>Right()</h2>
<pre>
void <b>Right</b> ();
</pre>

<P>See <a href="#Left">Left</a>.


<!-- ================================ -->
<h2 class=rule>
<a name=RunConfiguration></a>RunConfiguration()</h2>
<pre>
void <b>RunConfiguration</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>RunConfiguration()</b> function uses an XML file to define
how to assemble a STEP-NC data set. The function reads the file and
uses the tokens in that file to call other functions in the API with
appropriate arguments. The following tokens/XML functions are
currently recognized.<p>

<UL>
<li>Tool: calls the <a href="#DefineTool2">DefineTool2</a> function
with the given tool parameters. The XML attributes currently
recognized are &ldquo;slot&rdquo; for the tool number,
&ldquo;diameter&rdquo; for the tool diameter, &ldquo;id&rdquo; for the
tool identifier and &ldquo;geometry&rdquo; for the name of a file that
defines the tool geometry.
<li>ToolGeometry: calls the <a href="#ToolGeometry">ToolGeometry</a>
function to define the geometry of the tool after defining the tool
using <a href="#DefineTool2">DefineTool2</a>.
<li>Workpiece: calls the <a href="#Workpiece">Workpiece</a> function
with the given file name in an XML attribute called geometry.
<li>Rawpiece: calls the <a href="#Rawpiece">Rawpiece</a> function with
the given file name in an XML attribute called geometry.
<li>Fixture: calls the <a href="#Fixture">Fixture</a> function with
the given file name in an XML attribute called geometry.
</UL>

An example file is shown below. This file uses the tool_geometry
command so it expects to be used after an APT file has been read
defining the tool paths. The start_point command is therefore
redundant but included as an illustration.

<PRE class=code>
&lt;machine-setup>
&lt;start-point x="-5.225" y="-" z="5." />

&lt;tool_geometry tool="1" id="endmill_1in" diameter="1.0"
  geometry="tools/Cutters_inch/End_Mill_D_1.0.stp" />

&lt;tool_geometry tool="2" id="endmill_1/4in" diameter=".25"
  geometry="tools/Cutters_inch/End_Mill_025_English.stp" />

&lt;tool_geometry tool="3" id="drill_0.265in" diameter="0.265"
  geometry="tools/Cutters_inch/Drill_026.stp" />

&lt;workpiece geometry="sbir_test1_solid.203" />

&lt;/machine-setup>
</PRE>


<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD>The name of the XML file describing the
configuration.
</DL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SaveAsModules></a>SaveAsModules()</h2>
<div class = "tabview">
    <pre class=".net">
void <b>SaveAsModules</b> (
	System::String^ file_name
	);
</pre>

    <pre class="node.js">
void <b>SaveAsModules</b> (
	string file_name
	);
</pre>

    <pre class="C++">
RoseBoolean <b>save_file</b> (
	const char * filename,
	RoseBoolean asModules
	);
</pre>
</div>
<P>The <b>SaveAsModules()</b> function saves the STEP-NC program as a
STEP file with lots of system generated comments. A similar function
called <a href="#SaveAsPart21">SaveAsPart21</a> saves the STEP-NC
program as file without any comments.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD>Name of the file that is to be used to store the
data.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SaveAsPart21">SaveAsPart21</a>: Saves current project
into a file without any comments
<li><a href="#Open238">OpenProject()</a>: Reads STEP-NC data.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP-NC file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Ideally all errors are detected at the point of commission, but if
something is wrong then the file will contain badly defined data.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SaveAsModulesWithSTRL></a>SaveAsModulesWithSTRL()</h2>
<pre>
void <b>SaveAsModulesWithSTRL</b> (
	System::String^ filename,
	System::Int64 wp_id,
	System::Int64 ws_id,
	System::Int64 tp_id,
	double d
	);
</pre>

<P>The <b>SaveAsModulesWithSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SaveAsP21></a>SaveAsP21()</h2>
<div class = "tabview">
    <pre class=".net">
void <b>SaveAsP21</b> (
	System::String^ file_name
	);
</pre>

    <pre class="node.js">
void <b>SaveAsP21</b> (
	string file_name
	);
</pre>

    <pre class="C++">
RoseBoolean <b>save_file</b> (
	const char * filename,
	RoseBoolean asModules
	);
</pre>
</div>
<P>The <b>SaveAsP21()</b> function saves the STEP-NC program as an
file in clear text without comments. A similar function
called <a href="#SaveAsModules">SaveAsModules</a> save the STEP-NC
program as a file with system generated comments.


<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD>Name of the file that is to be used to store the
data.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SaveAsModules">SaveAsModules</a>: Saves the current
project into a file in the Part 28 XML format
<li><a href="#Open238">OpenProject</a>: Reads a STEP-NC file.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SaveAsP21WithSTRL></a>SaveAsP21WithSTRL()</h2>
<pre>
void <b>SaveAsP21WithSTRL</b> (
	System::String^ file_name,
	System::Int64 wp_id,
	System::Int64 ws_id,
	System::Int64 tp_id,
	double d
	);
</pre>

<P>The <b>SaveAsP21WithSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SaveFastAsModules></a>SaveFastAsModules()</h2>
<pre>
void <b>SaveFastAsModules</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>SaveFastAsModules()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SaveFastAsP21></a>SaveFastAsP21()</h2>
<pre>
void <b>SaveFastAsP21</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>SaveFastAsP21()</b> function



<!-- ================================ -->
<h2 class=rule>
<a name=SecondProject></a>SecondProject()</h2>
<pre>
void <b>SecondProject</b> (
	System::String^ filename,
	System::Int64 tool_mode
	);
</pre>

<P>The <b>SecondProject()</b> function copies the toolpath data from
one AP-238 file into another AP-238 file. If the coordinates of the
second AP-38 file need to be changed to match up with the first file,
then this can be done using the SecondProjectTransform function. If
the tool numbers of the second AP-238 file need to be changed so that
they do not conflict with those used by the first file, then they can
be changed using the tool number parameter.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>filename: <DD> The Name of the file that contains the second
project.
<DT>tool_mode: <DD> A value to add to each tool number in the second
file so that they do not conflict with the tool numbers in the first
file. For example if the both files are using numbers in the range 1
to 20 then a tool inc of 100 can be added to make the second file use
tool numbers in the range 101 to 120.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SecondProjectTransform">SecondProjectTransform</a>: Sets
a transform for the tool paths in the second project so that will line
up with the workpiece and other geometries defined for the first
project.
<li><a href="#NestWorkplan">NestWorkplan</a>:  Start a nested
workplan before executing the SecondProject so that all of the tool paths will
go in that workplan
<li><a href="#EndWorkplan">EndWorkplan</a>: End the nested workplan
after finishing the SecondProject.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li> There should be other options for matching the tools in the first
and second project. For example, the second project should be able to
search for tools in the first project that have the same parameters.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SecondProjectTransform></a>SecondProjectTransform()</h2>
<pre>
void <b>SecondProjectTransform</b> (
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>SecondProjectTransform()</b> function defines a
transformation matrix that will be applied to all of the tool path
points in a second project. The transform operates in the same way as
the transformation defined by
the <a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>
function but works on the tool paths instead of the part geometry.

<P>The transform defined by the SecondProjectTransform is reset to the
identity matrix after each call to the SecondProject function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD> New coordinates for the tool path origin.
<DT>i, j, k: <DD> New direction for the tool path Z axis
<DT>a, b, c: <DD>New direction for the tool path X axis
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SecondProject">SecondProject</a>:   Reads the AP-238
file that will be transformed.
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: See
function description for a description of how to define
transformations.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SELCTLTool></a>SELCTLTool()</h2>
<pre>
void <b>SELCTLTool</b> (
	System::Int64 selctl_number
	);
</pre>

<P>The <b>SELCTLTool()</b> function defines a tool number for the most
recently defined tool. The function also loads the tool. Therefore,
the next geometry item added to the data will cause a new workingstep
to be added to the project for the tool.

<P>The method used to define tools in APT is strange for unknown
legacy reasons. A tool is defined and then it may or may not be given
a number. If no number is given then the next available number is
used.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Tool_number: <DD>The number to be used for the previously defined
tool.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#IsToolDefined">IsToolDefined</a>:  Tests to see if the
tool exist.
<li><a href="#DefineTool">DefineTool</a>: Function used to define the
parameters for a tool.
<li><a href="#LoadTool">LoadTool</a>: Loads a tool and start a new
workingstep.
<li><a href="#ToolGeometry">ToolGeometry</a>: Defines AP-203 geometry
for the tool so that it can be seen in a simulation.
<li><a href="#SetToolAutoNumberOn">SetToolAutoNumber</a>: Lets the
application control the automatic numbering of tools.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>No tool: There is no tool available to be given the new number.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportActualFlutes></a>SetCNCexportActualFlutes()</h2>
<pre>
void <b>SetCNCexportActualFlutes</b> (
	System::Int64 tl_id,
	System::Int64 flts
	);
</pre>

<P>The <b>SetCNCexportActualFlutes()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportComments></a>SetCNCexportComments()</h2>
<pre>
void <b>SetCNCexportComments</b> (
	System::Int64 level
	);
</pre>

<P>The <b>SetCNCexportComments()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportExecDisabled></a>SetCNCexportExecDisabled()</h2>
<pre>
void <b>SetCNCexportExecDisabled</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>SetCNCexportExecDisabled()</b> function tells the various
CNC Export functions to not include data for this executable in the
output.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id: <DD>Identity of executable whose execution is to be
disabled
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
<li><a href="#WorkplanToSelective">WorkplanToSelective</a>: Defines a
workplan that must only contain one enabled executable
<li><a href="#SetCNCexportExecEnabled">SetCNCexportExecEnabled</a>:
Enables the execution of an executable
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP_NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
<li>Bad identity: The exe_id does not identify an executable such as a
workingstep, workplan or NC function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportExecEnabled></a>SetCNCexportExecEnabled()</h2>
<pre>
void <b>SetCNCexportExecEnabled</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>SetCNCexportExecEnabled()</b> function tells the various CNC
Export functions to include data for this executable in the
output. This is the default state

<h3>Arguments</h3>
<DL class=termdefs>
<DT>exe_id:<DD> Identity of executable whose execution is to be
enabled
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
<li><a href="#WorkplanToSelective">WorkplanToSelective</a>:  Defines a
workplan that must only contain one enabled executable
<li><a href="#SetCNCexportExecDisabled">SetCNCexportExecDisabled</a>:
Enables the execution of an executable
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
<li>Bad identity: The exe_id does not identify an executable such as a
workingstep, workplan or NC function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportExecSpeedprofileActive></a>SetCNCexportExecSpeedprofileActive()</h2>
<pre>
void <b>SetCNCexportExecSpeedprofileActive</b> (
	System::Int64 ws_id,
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportExecSpeedprofileActive()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportInsertStopAfterWorkingstep></a>SetCNCexportInsertStopAfterWorkingstep()</h2>
<pre>
void <b>SetCNCexportInsertStopAfterWorkingstep</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportInsertStopAfterWorkingstep()</b> function tells
the various CNC Export functions to insert a CNC stop code at the end
of each workingstep. The insertion is independent of the STEP-NC Stop
NC function and gives the operator more control when testing a new
STEP-NC program on a new machine.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>yn:<DD> true for on, false for off.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
<li><a href="#Stop">Stop</a>: Inserts a STOP NC function into the
current workplan
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportMatrixOn></a>
<a name=SetCNCexportMatrixOff></a>SetCNCexportMatrixOn/Off()</h2>
<pre>
System::Int64 <b>SetCNCexportMatrixOn</b> ();
void <b>SetCNCexportMatrixOff</b> ();
</pre>


<P>The <b>SetCNCexportMatrixOn()</b>
and <b>SetCNCexportMatrixOff()</b> functions are internal functions
used in some flexible setup tests.


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportNumberOfDigits></a>SetCNCexportNumberOfDigits()</h2>
<pre>
void <b>SetCNCexportNumberOfDigits</b> (
	System::Int64 num_digits
	);
</pre>

<P>The <b>SetCNCexportNumberOfDigits()</b> function tells the various
CNC Export functions how many digits to use for each number written
into the code. If the value is not set then the default depends on the
machine. For Siemens the default is 6 and for Fanuc it is 4.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>num_digits:<DD> The number of digits as an integer
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportProgramNum></a>SetCNCexportProgramNum()</h2>
<pre>
void <b>SetCNCexportProgramNum</b> (
	System::Int64 num
	);
</pre>

<P>The <b>SetCNCexportProgramNum()</b> function sets the preferred
program number to be used when writing machine control data.  In
particular, Fanuc and related controls use a numeric value at the
start of the program.  By default this value is zero and the default
for the style will be used.


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportSpeedOverride></a>SetCNCexportSpeedOverride()</h2>
<pre>
void <b>SetCNCexportSpeedOverride</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportSpeedOverride()</b> function sets a flag that
controls whether the CNC code generated will use the override speeds
computed by a feed speed optimizer instead of the base speeds stored
in the STEP-NC data.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>yn: <DD> true for on, false for off.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportToolOpts></a>SetCNCexportToolOpts()</h2>
<pre>
void <b>SetCNCexportToolOpts</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportToolOpts()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportTraceability></a>SetCNCexportTraceability()</h2>
<pre>
void <b>SetCNCexportTraceability</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportTraceability()</b> function sets a flag tha
controls whether code to trace the execution of the program will be
generated for the CNC control.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>yn: <DD> true for on, false for off.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportUnits></a>SetCNCexportUnits()</h2>
<pre>
void <b>SetCNCexportUnits</b> (
	System::String^ new_unit
	);
</pre>

<P>The <b>SetCNCexportUnits()</b> function defines the units that are
to be used for the CNC export file. If the units are different to
those used in the AP-238 data then they will be converted, for
example, from inch to millimeters.  The default is to use the same
units as the AP-238 file.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>units:<DD> The units given as a string. The following strings are
allowed: &ldquo;inch&rdquo; and &ldquo;millimeter&rdquo;.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportUsingBlocknumbers></a>SetCNCexportUsingBlocknumbers()</h2>
<pre>
void <b>SetCNCexportUsingBlocknumbers</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportUsingBlocknumbers()</b> function defines whether
or not block numbers are to be included in a CNC export file. Block
numbers are useful as a way to identify each line of code. The default
is to not use the block numbers unless it is required by the control
as is currently the case for Heidenhain controls.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>yn: <DD> true for on, false for off.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>:  An example of an export
function controlled using this function.
</UL>




<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportUsingTCP></a>SetCNCexportUsingTCP()</h2>
<pre>
void <b>SetCNCexportUsingTCP</b> (
	System::Boolean yn
	);
</pre>

<P>The <b>SetCNCexportUsingTCP()</b> function defines whether or not
Tool Center Point codes are to be included in a CNC export file. A CNC
file that uses Tool Center Point or Triori codes machines in part
space instead of machine space. For three-axis machining this has no
effect but for five-axis machining it makes the program more
independent and flexible.

<P>The default is to use TCP unless the Export function is
for a machine that does not support it.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>yn: <DD> true for on, false for off.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportFixture">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetCNCexportWorkoffset></a>SetCNCexportWorkoffset()</h2>
<pre>
void <b>SetCNCexportWorkoffset</b> (
	System::Int64 offset_register
	);
</pre>

<P>The <b>SetCNCexportWorkoffset()</b> function sets the CNC work
offset mode to be selected during an export. The default is to not use
an offset.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Offset_register: <DD>The number of the offset register. A value of
1 corresponds to G54, 2 to G55 and 5 to G58.  A value of 0 means do
nothing about offsets.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#ExportAsFanuc">ExportAsFanuc</a>: An example of an
export function controlled using this function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetDebuggingNamesOn></a>
<a name=SetDebuggingNamesOff></a>SetDebuggingNamesOn/Off()</h2>
<pre>
void <b>SetDebuggingNamesOn</b> ();
void <b>SetDebuggingNamesOff</b> ();
</pre>

<P>During testing name values can be set in many places in a STEP file
to help trace issues and problems in the data. By setting the
DebuggingName to Off this space can be saved and is the normal default
operation mode for the API. Use SetDebuggingNamesOn to change this
behavior and put the names into the data.



<!-- ================================ -->
<h2 class=rule>
<a name=SetDefineArcUsingViaOn></a>
<a name=SetDefineArcUsingViaOff></a>SetDefineArcUsingViaOn/Off()</h2>
<pre>
void <b>SetDefineArcUsingViaOn</b> ();
void <b>SetDefineArcUsingViaOff</b> ();
</pre>

<P>If DefineArcUsingVia is on then arc data is stored in a reduced
format that considerably reduces the size of STEP-NC files that
contain a lot of arc data such as high speed machining files.

<P>If DefineArcUsingVia is off then the full STEP definition for an
arc is used. This definition allows an arc to be used in many
different contexts but is verbose and redundant in the context of a
continuous tool path.

<P>The default is for DefineArcUsingVia to be on. If an application
needs to share arc&rsquo;s between tool paths and other kinds of
geometry (such as faces) then this value should be changed to off.


<!-- ================================ -->
<h2 class=rule>
<a name=SetDirection></a>SetDirection()</h2>
<pre>
void <b>SetDirection</b> (
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>SetDirection()</b> function sets a default axis that can be
used by other functions. In the APT object only
the <a href="#Arc">Arc</a> commands use this direction. The Feature
object has many functions that use the direction.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>i, j, k: <DD> The i, j, k components of the direction Z axis.
<DT>a, b, c: <DD> The a, b, c components of the direction X axis.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Arc">Arc</a>: This function uses the SetDirection to
define the plane that will contain the arc.
<li><a href="#ArcABC">ArcABC</a>: Also uses SetDirection
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li> A good argument can be made for extending the arc command to
include the direction parameters. The counter argument is that most
arcs are in the XY plane (the default) so using a second function is
more economical.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetLocation></a>SetLocation()</h2>
<pre>
void <b>SetLocation</b> (
	double x,
	double y,
	double z
	);
</pre>

<P>The <b>SetLocation()</b> function sets a default position that can
be used by other functions. Currently there are no functions in the
APT that use this value, but the Feature object has many such
functions.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD> The coordinates of the position.
</DL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP_NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetMaximumDeviation></a>SetMaximumDeviation()</h2>
<pre>
void <b>SetMaximumDeviation</b> (
	double value
	);
</pre>

<P>The <b>SetMaximumDeviation()</b> function defines the maximum
deviation allowed for the ideal curve for a tool path. In APT and BCL
this value is know as the &ldquo;LinTol&rdquo; for linearization
tolerance. If set this value is put into the tool path data alongside
the coordinate and axis data. The space consumed is not significant if
the whole path uses the same value.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>value: <DD>The maximum deviation value.
</DL>
<h3>Common Errors</h3>
<UL>
<li>No project open: An STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetModeMill></a>SetModeMill()</h2>
<pre>
void <b>SetModeMill</b> ();
</pre>

<P>The STEP-NC API can operate in Milling mode or Turning mode. In
milling mode which is the default the explorer creates milling
workingsteps, milling technology and milling machine functions. In
turning mode it creates turning workingsteps, turning technology and
turning machine functions.

<P>If the API is in turning mode when this function is called, then
any currently open tool path or workingstep will be closed and a new
step and path will be created when new geometry is added to the
program.

<h3>Related Functions</h3>
<UL>
<li><a href="#SetModeTurn">SetModeTurn</a>: Puts the API into turning
mode.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetModeTurn></a>SetModeTurn()</h2>
<pre>
void <b>SetModeTurn</b> ();
</pre>

<P>See <a href="#SetModeMill">SetModeMill</a>.  If the API is in
milling mode when this function is called, then any open tool path or
workingstep will be closed and a new step and path will be created.
The milling mode has been much more extensively tested than the
turning mode.


<!-- ================================ -->
<h2 class=rule>
<a name=SetName></a>SetName()</h2>
<pre>
void <b>SetName</b> (
	System::Int64 ent_id,
	System::String^ name
	);
</pre>

<P>Many objects in the API have names or
identifiers. The <b>SetName()</b> function function sets the names of
those objects to a given string.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ent_id: <DD> The identity of an executable, project, feature,
workpiece or other type of STEP-NC entity that has a name attribute.
<DT>Name: <DD> The new value for the name. If null then the name will
be set to &ldquo;&rdquo;.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SetNameGet">SetNameGet</a>: Get the current name for an
object.
<li><a href="#SetNameType">SetNameType</a>: The type of the object.
<li><a href="#SetUUID">SetUUID_if_not_set()/force()</a>: Set the UUID of an object.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
<li>Bad identity: This type of object does not have a name.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameCheckSTRL></a>SetNameCheckSTRL()</h2>
<pre>
System::Int64 <b>SetNameCheckSTRL</b> (
	System::Int64 ent_id
	);
</pre>

<P>The <b>SetNameCheckSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameCreateSTRL></a>SetNameCreateSTRL()</h2>
<pre>
System::String^ <b>SetNameCreateSTRL</b> (
	System::Int64 wp_id,
	System::Int64 ws_id,
	System::Int64 tp_id,
	double d
	);
</pre>

<P>The <b>SetNameCreateSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameGet></a>SetNameGet()</h2>
<div class="tabview">
<pre class=".net">
System::String^ <b>SetNameGet</b> (
	System::Int64 ent_id
	);
</pre>
<pre class="node.js">
string <b>SetNameGet</b> (
	int ent_id
	);
</pre>
<pre class="C++">
RoseBoolean <b>get_name</b> (
	int ent_id, 
	const char * &name
	);
</pre>
</div>

<P>Many objects in the API have names or
identifiers. The <b>SetNameGet()</b> function returns the current
names of these objects.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ent_id: <DD> The identity of an executable, project, feature,
workpiece or other type of STEP-NC entity that has a name attribute.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SetName">SetName</a>: Set the name for an object.
<li><a href="#SetNameType">SetNameType</a>: Get the type of a named
object.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: A STEP-NC file must be open - see
the <a href="#Open238">OpenProject</a> function.
<li>Bad identity: This type of object does not have a name.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameGetSTRL></a>SetNameGetSTRL()</h2>
<pre>
System::String^ <b>SetNameGetSTRL</b> (
	System::Int64 ent_id
	);
</pre>

<P>The <b>SetNameGetSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameHasSTRL></a>SetNameHasSTRL()</h2>
<pre>
System::Int64 <b>SetNameHasSTRL</b> (
	System::Int64 ent_id
	);
</pre>

<P>The <b>SetNameHasSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameHitSTRL></a>SetNameHitSTRL()</h2>
<pre>
System::Int64 <b>SetNameHitSTRL</b> (
	System::Int64 ent_id
	);
</pre>

<P>The <b>SetNameHitSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameSTRL></a>SetNameSTRL()</h2>
<pre>
void <b>SetNameSTRL</b> (
	System::Int64 ent_id,
	System::String^ strl
	);
</pre>

<P>The <b>SetNameSTRL()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=SetNameType></a>SetNameType()</h2>
<pre>
System::String^ <b>SetNameType</b> (
	System::Int64 ent_id
	);
</pre>

<P>The <b>SetNameType()</b> function returns a string describing the
type of the entity.  Many objects in the API have names or
identifiers. This function returns the type of one of these objects.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ent_id: <DD> The identity of an executable, project, feature,
workpiece or other type of STEP-NC entity that has a name attribute.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SetName">SetName</a>: Set the current name for an
object.
<li><a href="#SetNameGet">SetNameGet</a>: Get the current
name for an object.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=SetToolAutoNumberOn></a>
<a name=SetToolAutoNumberOff></a>SetToolAutoNumberOn/Off()</h2>
<pre>
void <b>SetToolAutoNumberOn</b> ();
void <b>SetToolAutoNumberOff</b> ();
</pre>

<P>In APT programs a tool is identified by a tool number that
corresponds to the placement position of the tool in a tool
holder. The Selectl and LoadTool functions in the API allow tools to
be selected and loaded using these numbers.

<P>The <a href="#DefineTool">DefineTool</a> function is used to define
a tool using the parameters defined by APT. However, the DefineTool
command does not define a tool number. Instead two options are
possible. In the first option the tool number is given using the APT
SELCTL command that corresponds to the
API <a href="#SELCTLTool">SELCTLTool</a> function. In the second
option the next available tool number is used.

<P>The <b>SetToolAutoNumberOff()</b> function is used to control this
behavior. If SetAutoToolNumber is on then the next available number
will be give to a tool as soon as it is defined. If it is off the API
will wait for the SELECTL command to give it a number.

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>: Defines the parameters of a
tool such as the length and diameter.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li> Subtle differences between the semantics of how tools are defined
are a frequent cause of errors when the API is applied to the APT
files of a new organization for the first time.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=SetToolIdentifier></a>SetToolIdentifier()</h2>
<pre>
void <b>SetToolIdentifier</b> (
	System::String^ tool_number,
	System::String^ identifier
	);
</pre>

<P>The <b>SetToolIdentifier()</b> function sets the
manufacturer&rsquo;s name for the tool.  For example, it might be
&ldquo;Sandvik Endmill 0.4 mm&rdquo;. The tool identifier allows the
tool to be found in external databases and catalogs. In the STEP-NC
API a tool must have an identifier before it can be given
geometry. The identifier can be defined using this function,
the <a href="#DefineTool2">DefineTool2</a> function or as a side
effect of
the <a href="#GeometryForToolNumber">GeometryForToolNumber</a>
function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Number: <DD> The tool number given as a string. STEP-NC allows any
string to be used as an identifier but some APT parsers assume that
the next tool will be given the next number so not using a number may
cause difficulties.
<DT>Identifier: <DD> The identifier for the tool also given as a
string.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>:   Defines a
tool.
<li><a href="#DefineTool2">DefineTool2</a>:   Defines a
tool with an identifier.
<li><a href="#ToolGeometry">ToolGeometry</a>:   Defines the
geometry of a tool but requires the identifier to be defined first.
<li><a href="#GeometryForToolNumber">GeometryForToolNumber</a>: Allows
the tool geometry to be defined without giving an explicit
identifier. Instead an identifier is generated by pre-pending a
&ldquo;T&rdquo; to the tool number.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Tool not found: There is no tool in the database with the number.
</ul>


<!-- ================================ -->
<h2 class=rule>
<a name=SetToolNumber></a>SetToolNumber()</h2>
<pre>
void <b>SetToolNumber</b> (
	System::String^ old_id,
	System::String^ new_id
	);
</pre>

<P>The <b>SetToolNumber()</b> function changes the number of a tool
when an application does not want to use the numbers assigned by an
APT program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>old_id:<DD> The old id given as a string because STEP-NC does not
require the tool number to be an integer.
<DT>new_id:<DD>  Also
given as a string.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>: Defines the parameters of a
tool such as the length and diameter.
<li><a href="#SELCTLTool">SELCTLTool</a>: Defines a tool number for
the most recently defined tool.
<li><a href="#LoadTool">LoadTool</a>: Starts a new workingstep using
the tool with the given tool number
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Tool not found: There is no tool in the database with the old
number/id.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=SetUUID></a>SetUUID_force()/_if_not_set()/to_string()</h2>
<pre>
System::String^ <b>SetUUID_force()</b> (
	System::Int64 entity_id
	);
</pre>
<pre>
System::String^ <b>SetUUID_if_not_set()</b> (
	System::Int64 entity_id
	);
</pre><pre>
System::String^ <b>SetUUID_to_string()</b> (
	System::Int64 entity_id
	System::String^ uuid_str
	);
</pre>

<P>A UUID is a number that in practice
will never be generated again. The <b>SetUUID_if_not_set()</b> function assigns a Universally Unique IDentifier
to an entity if one has not yet been set.
The <b>SetUUID_force()</b> function assigns a new Universally Unique IDentifier
to an entity and should be used whenever the underlying value of the concept represented by that entity
has changed.
The <b>SetUUID_to_string()</b> function sets the UUID to a given string which must be unique. The intended use of this function
is for when an old copy of an object has been deleted and a new copy has been created as a replacement with the same 
identity.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>entity_id: <DD> The internal (STEP Part 21) identity of an entity.
<DT>uuid_str: <DD> The UUID to be given to the object which must be unique.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#GetUUID">GetUUID</a>:   Gets the UUID currently assigned to an entity.
<li><a href="#SetName">SetName()</a>: Set the name of an entity to a given string.</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Diallowed: The entity does not represent a concept
currently deemed worthy of a UUID. Call STEP Tools if
this is an issue.
<li>Duplicate: The UUIID is already used for another entity
make sure it is deleted before you reassign the value.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Shutdown></a>Shutdown()</h2>
<pre>
void <b>Shutdown</b> ();
</pre>

<P>The <b>Shutdown()</b> function is a version of
the <a href="#Reset">Reset</a> function deletes all of the data in the
APT object as well as resetting it to its initial state. If multiple
applications are sharing the same object then all but the last object
should execute a reset and after they have finished the last should
shutdown it down.



<!-- ================================ -->
<h2 class=rule>
<a name=SpindleSpeed></a>SpindleSpeed()</h2>
<pre>
void <b>SpindleSpeed</b> (
	double speed
	);
</pre>

<P>The <b>SpindleSpeed()</b> function defines the spindle speed to be
used by all subsequent tool paths.

<P>If a toolpath is currently being constructed then it is finished
and a new one is started for the next geometry item with the new
spindle speed. If the API is <u>not</u> in &ldquo;CAM Mode&rdquo; then
a new workingstep is also constructed because in APT files changes in
Spindle speed usually only happen at the start or end of an operation.

<P>The system is put into &ldquo;CAM Mode&rdquo; if the application
starts to create its own workingsteps using
the <a href="#Workingstep">Workingstep</a> function. There are also
explicit <a href="#CamModeOn">CamModeOn</a>
and <a href="#CamModeOff">CamModeOff</a> functions. In CAM mode the
API assumes it is being controlled by a CAM translation application
that can make its own decisions about the best boundaries between
workingsteps so it only creates new workingsteps when forced to by a
change in tool.

<P>The unit of the Spindle speed can be set using
the <a href="#SpindleSpeedUnit">SpindleSpeedUnit</a> function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Speed: <DD> The value for the new speed. The SpindleSpeed function
is a null operation if the new feed is the same as the current speed.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SpindleSpeedUnit">SpindleSpeedUnit</a>: Used to define
the spindle speed unit.
<li><a href="#Feedrate">Feedrate</a>: Defines the feedrate.
<li><a href="#Workingstep">Workingstep</a>: Starts a new workingstep
and put the API into &ldquo;CAM Mode&rdquo;
<li><a href="#CamModeOn">CamModeOn</a>:  Turns CAM mode on.
<li><a href="#CamModeOff">CamModeOff</a>: Turns CAM mode off (the
default) in this mode each call to Spindle creates a new workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=SpindleSpeedUnit></a>SpindleSpeedUnit()</h2>
<pre>
void <b>SpindleSpeedUnit</b> (
	System::String^ unit
	);
</pre>

<P>The <b>SpindleSpeedUnit()</b> function defines the units to be used
for all subsequent spindle speeds. The function should be followed by
a call to <a href="#SpindleSpeed">SpindleSpeed</a> to set the new
spindle speed value. The function sets the current speed to 0. The
function sets the technology object to NULL until a new one is needed
for a new tool path.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Unit: <DD> The unit to be used for future spindle speeds as
described by one of the following strings.
<UL>
<li> &ldquo;hertz&rdquo; cycles per second
<li> &ldquo;rpm&rdquo; revolutions per minute
</UL>
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#SpindleSpeed">SpindleSpeed</a>: Sets spindle speed
value.
<li><a href="#GetCurrentTech">GetCurrentTech</a>: Returns the
identifier of the technology object currently being used to define
feeds and speeds for new tool paths.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Invalid string: The string describing the units does not have one
of the values recognized by the STEP-NC API.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=Stop></a>Stop()</h2>
<pre>
void <b>Stop</b> (
	System::String^ label
	);
</pre>

<P>The <b>Stop()</b> function adds the Stop NC function to the current
workplan. The Stop function stops the program.

<P>If a workingstep and toolpath is open when an NC function is added
then that workingstep and toolpath will be ended, and a new
workingstep and toolpath will be started if any new tool path geometry
is added to the program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD> A label that can be used to identify the stop.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#OptionalStop">OptionalStop</a>: Adds an optional stop to
the STEP-NC program.
<li><a href="#SetCNCexportInsertStopAfterWorkings">SetCNCexportInsertStopAfterWorkingstep</a>:
Tells the STEP-NC to ISO 6983 converter functions
(<a href="#ExportFixture">ExportAsFanuc</a> etc) to put a Stop at the
end of every workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=StopAfter></a>StopAfter()</h2>
<pre>
System::Int64 <b>StopAfter</b> (
	System::String^ label,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>StopAfter()</b> function inserts a Stop NC function into a
given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Label: <DD> A label for the new function
<DT>Index: <DD> The position relative to the start of the workplan
where the workingstep is to be placed. If the index is less than 0
then it will be placed at the start of the workplan. If it is equal to
or greater than the size of the workplan then it will be placed after
the end. Otherwise it will be placed after the item in the current
position.
<DT>Plan_id <DD>The identifier of the workplan into which the
workingstep is to be inserted. See Seciton for a description of how to
use identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#OptionalStopAfter">OptionalStopAfter</a>: Adds an
optional stop to the STEP-NC program.
<li><a href="#Stop">Stop</a>: Adds the stop to the current end of the
program.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=STRLCapture></a>STRLCapture()</h2>
<pre>
System::Int64 <b>STRLCapture</b> (
	System::Int64 wp_id,
	System::Int64 ws_id,
	System::Int64 tp_id,
	double d
	);
</pre>

<P>The <b>STRLCapture()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=STRLRestore></a>STRLRestore()</h2>
<pre>
System::Int64 <b>STRLRestore</b> (
	[System::Runtime::InteropServices::Out] System::Int64 %wp_id,
	[System::Runtime::InteropServices::Out] System::Int64 %ws_id,
	[System::Runtime::InteropServices::Out] System::Int64 %tp_id,
	[System::Runtime::InteropServices::Out] double %d
	);
</pre>

<P>The <b>STRLRestore()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=ToolGeometry></a>ToolGeometry()</h2>
<pre>
void <b>ToolGeometry</b> (
	System::String^ file_name,
	System::String^ tool_identifier
	);
</pre>

<P>The <b>ToolGeometry()</b> function defines the geometry of a tool
using an STEP CAD file. A tool must have an identifier before it can be
given geometry. The identifier can be defined using
the <a href="#SetToolIdentifier">SetToolIdentifier</a> function,
the <a href="#DefineTool2">DefineTool2</a> function or as a side
effect of
the <a href="#GeometryForToolNumber">GeometryForToolNumber</a>
function. The latter function is a simpler interface for this
function.

<P>For proper visualization and simulation, the origin of the tool
geometry must be at the tip of the tool and the center line of the
tool must be the z axis.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the file that contains the AP-203
geometry for the tool.
<DT>Identifier<DD> The identifier for the tool as a string.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#DefineTool">DefineTool</a>: Defines the parametric
parameters of a tool such as the diameter, length and tool tip radius.
<li><a href="#DefineTool2">DefineTool2</a>: Defines the parametric
parameters and a tool identifier.
<li><a href="#SetToolIdentifier">SetToolIdentifier</a>: Defines the
identifier of the tool.
<li><a href="#GeometryForToolNumber">GeometryForToolNumber</a>: Allows
the tool geometry to be defined without giving an explicit
identifier. Instead an identifier is generated by pre-pending a
&ldquo;T&rdquo; to the tool number.
<li><a href="#ExportToolGeometry">ExportToolGeometry</a>: Export the
geometry of a tool as an STEP CAD file.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Tool not found: There is no tool in the database with the given
identifier.
<li>Bad tool name: The geometry file must not have the same name as
the project
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=URLGet></a>URLGet()</h2>
<pre>
System::String^ <b>URLGet</b> ();
</pre>

<P>The <b>URLGet()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=URLHas></a>URLHas()</h2>
<pre>
System::Int64 <b>URLHas</b> ();
</pre>

<P>The <b>URLHas()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=URLSet></a>URLSet()</h2>
<pre>
void <b>URLSet</b> (
	System::String^ new_url
	);
</pre>

<P>The <b>URLSet()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=UsingEnglishUnits></a>UsingEnglishUnits()</h2>
<pre>
System::Boolean <b>UsingEnglishUnits</b> ();
</pre>

<P>The <b>UsingEnglishUnits()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=UsingFrenchUnits></a>UsingFrenchUnits()</h2>
<pre>
System::Boolean <b>UsingFrenchUnits</b> ();
</pre>

<P>The <b>UsingFrenchUnits()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=Workingstep></a>Workingstep()</h2>
<pre>
void <b>Workingstep</b> (
	System::String^ label
	);
</pre>

<P>The <b>Workingstep()</b> function starts a new workingstep in the
current workplan. The function also sets the API to &ldquo;CAM
mode&rdquo; which means future calls to
the <a href="#SpindleSpeed">SpindleSpeed</a> function will no longer
start a new workingstep.

<P>The workingstep function is designed to be called by applications
that are translating CAM data to AP-238. These applications can use
the functions in the Process object to define AP-238 process data.<p>.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Name <DD>A name that can be used to identify the workingstep. The
name is frequently shown to the users by applications so it should be
meaningful.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingstepAfter">WorkingstepAfter</a>: This function
has parameters to control the placement of the new workingstep in an
existing program.
<li><a href="#NestWorkplan">NestWorkplan</a>: This function starts a
new workplan.
<li><a href="#EndWorkplan">EndWorkplan</a>: This function ends a
workplan. There is no explicit end workingstep function. A workingstep
is ended when another workingstep is started.
<li><a href="#LoadTool">LoadTool</a>: This function is used by APT
programs to define a new tool and by implication a new workingstep
because a workingstep can only have one tool.
<li><a href="#SpindleSpeed">SpindleSpeed</a>: This function is used by
APT programs to change the spindle speed and unless the system is in
CAM mode it will also create a new workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepAfter></a>WorkingstepAfter()</h2>
<pre>
System::Int64 <b>WorkingstepAfter</b> (
	System::String^ label,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>WorkingstepAfter()</b> function creates a new workingstep at
a given location in a given workplan. It does not change the
&ldquo;CAM mode&rdquo;.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>Name <DD>A name that can be used to identify the workingstep. The
name is frequently shown to the users by applications so it should be
meaningful.
<DT>Index: <DD> The position relative to the start of the workplan
where the workingstep is to be placed. If the index is less than 0
then it will be placed at the start of the workplan. If it is equal to
or greater than the size of the workplan then it will be placed after
the end. Otherwise it will be placed after the item in the current
position.
<DT>Plan_id <DD>The identifier of the workplan into which the
workingstep is to be inserted. See Seciton for a description of how to
use identifiers.
<li> </DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Workingstep">Workingstep</a>: This function creates a
new workingstep at the end of the current workplan.
<li><a href="#NestWorkplanAfter">NestWorkplanAfter</a>: This function
starts a new workplan at an arbitrary location.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepOperationReuse></a>WorkingstepOperationReuse()</h2>
<pre>
void <b>WorkingstepOperationReuse</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>WorkingstepOperationReuse()</b> function creates a
workingstep by reusing the operation in a given workingstep. This will
allow the data to be transformed to a new location and orientation
using the WorkingstepToolpathOrientation function.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id <DD>The identity of the workingstep whose operation is to be
repeated.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingStepOperationReuseAfter">WorkingstepOperationReuseAfter</a>:
This function has parameters to control the placement of the repeated
workingstep.
<li><a href="#WorkingstepToolpathOrientation">WorkingstepToolpathOrientation</a>:
Function to control the placement of the repeated operation.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepOperationReuseAfter></a>WorkingstepOperationReuseAfter()</h2>
<pre>
void <b>WorkingstepOperationReuseAfter</b> (
	System::Int64 ws_id,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>WorkingstepOperationReuseAfter()</b> function Repeats a
workingstep operation and puts it at a given location in the STEP-NC
program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id <DD>The identity of the workingstep that is to be repeated.
<DT>index: <DD> The desired position for the workingstep in the
workplan.
<DT>plan_id: <DD> The identity of the workplan that is to contain the
repeated workingstep. See Section for some important notes on how to
use identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingstepOperationReuse">WorkingstepOperationReuse</a>:
Repeats the workingstep at the current end of the STEP-NC program.
<li><a href="#WorkingstepToolpathOrientation">WorkingstepToolpathOrientation</a>:
Function to control the placement of the repeated operation.

</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
<li>Index range: Index is out of range for the workplan list [0, count
&ndash; 1]
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepReuse></a>WorkingstepReuse()</h2>
<pre>
void <b>WorkingstepReuse</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>WorkingstepReuse()</b> function repeats a workingstep by
putting it into the current workplan. For example, if the same
operation is needed in more than one alternative of a Selective.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id <DD>The identity of the workingstep that is to be repeated.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingStepReuseAfter">WorkingstepReuseAfter</a>: This
function has parameters to control where the repeated workingstep is
placed in a workplan.
<li><a href="#ExecutableReuse">ExecutableReuse</a>: Repeat any kind of
executable including a workingstep, nc function, workplan or
selective.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepReuseAfter></a>WorkingstepReuseAfter()</h2>
<pre>
void <b>WorkingstepReuseAfter</b> (
	System::Int64 ws_id,
	System::Int64 index,
	System::Int64 plan_id
	);
</pre>

<P>The <b>WorkingstepReuseAfter()</b> function repeats a workingstep
at a given location in the STEP-NC program.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id <DD>The identity of the workingstep that is to be repeated.
<DT>Index: <DD> The desired position for the workingstep in the
workplan.
<DT>Plan_id: <DD> The identity of the workplan that is to contain the
repeated workingstep. See Section for some important notes on how to
use identifiers.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingstepReuse">WorkingstepReuse</a>: Repeats the
workingstep at the current end of the STEP-NC program.
<li><a href="#ExecutableReuseAfter">ExecutableReuseAfter</a>: Repeat
any kind of executable including a workingstep, nc function, workplan
or selective.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepToolpathOrientation></a>WorkingstepToolpathOrientation()</h2>
<pre>
void <b>WorkingstepToolpathOrientation</b> (
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkingstepToolpathOrientation()</b> function defines a
coordinate transformation for the toolpaths in the current
workingstep.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>x, y, z: <DD> The origin of the placement.
<DT>i, j, k: <DD> The Z axis direction of the placement.
<DT>a, b, c: <DD> The X axis direction of the placement.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#Workingstep">Workingstep</a>: Create a new current
workingstep.
<li><a href="#WorkingstepToolpathOrientationReuse">WorkingstepToolpathOrientationReuse</a>:
Use the orientation of one toolpath in another (useful when an orientation
has to be repeated for many steps).
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepToolpathOrientationDelete></a>WorkingstepToolpathOrientationDelete()</h2>
<pre>
void <b>WorkingstepToolpathOrientationDelete</b> (
	System::Int64 ws_id
	);
</pre>

<P>The <b>WorkingstepToolpathOrientationDelete()</b> function deletes
the toolpath orientation of a workingstep so that the toolpaths will
appear at their defined (native) coordinates.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws_id: <DD> The identity of the workingstep.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingstepToolpathOrientation">WorkingstepToolpathOrientation</a>:
Define an orientation for the toolpaths in a workingstep.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws_id does not identify a workingstep.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkingstepToolpathOrientationReuse></a>WorkingstepToolpathOrientationReuse()</h2>
<pre>
void <b>WorkingstepToolpathOrientationReuse</b> (
	System::Int64 reuse_ws_id,
	System::Int64 in_ws_id
	);
</pre>

<P>The <b>WorkingstepToolpathOrientationReuse()</b> function defines
the orientation of a workingstep by reusing a previously defined
orientation.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>ws1_id: <DD> The identity of the workingstep whose orientation is
to be set.
<DT>ws2_id: <DD> The identity of the workingstep whose orientation is
to be reused.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkingstepToolpathOrientation">WorkingstepToolpathOrientation</a>:
Define an orientation for the toolpaths in a workingstep.
<li><a href="#WorkingstepOperationReuse">WorkingstepOperationReuse</a>:
Duplicate the operation in a workingstep so that it can have a new
orientation set.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The ws1_id or ws2_id does not identify a
workingstep.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=Workpiece></a>Workpiece()</h2>
<pre>
void <b>Workpiece</b> (
	System::String^ filename
	);
</pre>

<P>The <b>Workpiece()</b> function defines the geometry of the
workpiece from an STEP CAD file. The function assumes that all of the
geometry in the file is to make up the workpiece. Any STEP file can be
used to define the geometry provided it is compatible with AP-203. If
the STEP file is an AP-203 Edition 2 file then tolerances and
dimensions can be defined for the workpiece. The
<A href="Tolerance.html">Tolerance</A> object has more information on
how tolerances are processed in the API.

<P>The new workpiece is made the default workpiece of the
project. More specific workpieces can be defined for each workplan
using <a href="#WorkplanWorkpiecePlacementAdd">WorkplanWorkpiecePlacementAdd</a>
and for each executable using
the <a href="#ExecutableWorkpieceAsIs">ExecutableWorkpiece</a>
functions.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>File name: <DD> The name of the STEP file that defines the
workpiece.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>: This
function changes the placement of the workpiece so that it can be
positioned and oriented correctly within the context of the tool
paths.
<li><a href="#ExportWorkpiece">ExportWorkpiece</a>: This function
exports an STEP CAD file describing the rawpiece.
<li><a href="#Rawpiece">Rawpiece</a>: Performs the same function as
workpiece but for the rawpiece
<li><a href="#Fixture">Fixture</a>: Performs the same function as
workpiece but for the fixture.
<li><a href="#GetCurrentWorkpiece">GetCurrentWorkpiece</a>: Returns
the id of the current workpiece or null (0).
<li><a href="#PartNo">PartNo</a>: This function gives a name to the
workpiece without defining any geometry and/or changes the name of the
current workpiece.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad File: The API was unable to open a file with the given name or
it was not a valid STEP file.
<li>Bad name: The workpiece cannot have the same name as the project.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkpieceAndRawpiece></a>WorkpieceAndRawpiece()</h2>
<pre>
void <b>WorkpieceAndRawpiece</b> (
	System::String^ file_name
	);
</pre>

<P>The <b>WorkpieceAndRawpiece()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=WorkpieceSecondPlacement></a>WorkpieceSecondPlacement()</h2>
<pre>
System::Int64 <b>WorkpieceSecondPlacement</b> (
	System::Int64 wp_id,
	System::String^ name,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkpieceSecondPlacement()</b> function


<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanFromSelective></a>WorkplanFromSelective()</h2>
<pre>
System::Int64 <b>WorkplanFromSelective</b> (
	System::Int64 sel_id
	);
</pre>

<P>The <b>WorkplanFromSelective()</b> function converts a selective
workplan back to being a regular workplan.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan that is to be converted
to a selective.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkplanToSelective">WorkplanToSelective</a>: Function
to convert a regular workplan into a selective workplan.
</UL>

<h3>Common Errors</h3>
<UL>
<li> No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a selective workplan.
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetup></a>WorkplanSetup()</h2>
<pre>
void <b>WorkplanSetup</b> (
	System::Int64 plan_id,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkplanSetup()</b> function defines a coordinate system for
both the toolpaths in the workplan and the workpiece models of that
workplan. Different workplans can have different setups so that for
example one workplan mills the top face of a part and another workplan
mills the bottom face.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan.
<DT>x, y, z: <DD> The origin of the placement.
<DT>i, j, k: <DD> The Z axis direction of the placement.
<DT>a, b, c: <DD> The X axis direction of the placement.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#PutWorkpiecePlacement">PutWorkpiecePlacement</a>:
Function used to define the placement of a workpiece.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a workplan.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetupDelete></a>WorkplanSetupDelete()</h2>
<pre>
void <b>WorkplanSetupDelete</b> (
	System::Int64 plan_id
	);
</pre>

<P>The <b>WorkplanSetupDelete()</b> function deletes a workplan setup
and any associated data such as the placement of the workpiece on the
fixture and the fixture on the machine tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan that contains the setup
that is to be deleted.
</DL>

<h3>Related Functions</h3>
<UL>
<li><a href="#WorkplanWorkpiecePlacementAdd">WorkplanSetup</a>:
Function to define the setup of a workplan.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a workplan with a
setup.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetupFixture></a>WorkplanSetupFixture()</h2>
<pre>
void <b>WorkplanSetupFixture</b> (
	System::Int64 plan_id,
	System::String^ file_name
	);
</pre>

<P>The <b>WorkplanSetupFixture()</b> function defines the geometry of
the fixture from an STEP CAD file. The function assumes that all of
the geometry in the file is to make up the fixture. Any STEP file can
be used provided it is compatible with AP-203. It is quite common for
a fixture to be defined as an assembly of parts such as four bolts. If
the file is an AP-203 Edition 2 file then the geometry may include
dimensions and tolerances.

<P>The fixture is placed in the coordinate system defined by the setup
which defaults to the origin if undefined.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>file name: <DD> The name of the STEP file that defines the
fixture.
<DT>plan_id: <DD> The identify of the workplan that is to contain the
fixture.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#WorkplanWorkpiecePlacementAdd">WorkplanSetup</a>:
Defines the coordinate system to be used by a setup.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see the NewProject
function.
<li>Bad File: The API was unable to open a file with the given name or
it was not a valid STEP file.
<li>Bad name: The fixture cannot have the same name as the project.
<li>Bad id: The plan_id does not identify a workplan
</UL>

<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetupFixtureMountPut></a>
<a name=WorkplanSetupFixtureMountGet></a>WorkplanSetupFixtureMountGet/Put()</h2>
<pre>
void <b>WorkplanSetupFixtureMountGet</b> (
	System::Int64 plan_id,
	[System::Runtime::InteropServices::Out] double %x,
	[System::Runtime::InteropServices::Out] double %y,
	[System::Runtime::InteropServices::Out] double %z,
	[System::Runtime::InteropServices::Out] double %i,
	[System::Runtime::InteropServices::Out] double %j,
	[System::Runtime::InteropServices::Out] double %k,
	[System::Runtime::InteropServices::Out] double %a,
	[System::Runtime::InteropServices::Out] double %b,
	[System::Runtime::InteropServices::Out] double %c
	);

void <b>WorkplanSetupFixtureMountPut</b> (
	System::Int64 plan_id,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkplanSetupFixtureMountGet()</b> function gets the
coordinates of the fixture mount.

<P>The <b>WorkplanSetupFixtureMountPut()</b> function defines where to
put the fixture on the machine. This function completes the chain of
connections by defining where the fixture is to be placed on the
machine tool.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD>  The identity of the workplan.
<DT>x, y, z: <DD> The origin of the placement.
<DT>i, j, k: <DD> The Z axis direction of the placement.
<DT>a, b, c: <DD> The X axis directionof the placement.
</DL>

<h3>Related Functions</h3>
<UL>
<li>The <a href="#WorkplanSetupPut">WorkplanSetupPut</a> function
defines the coordinate system of the workplan. For example, the workpiece may
be turned over so that the bottom face is milled in this setup.

<li>The <a href="#WorkplanSetupFixtureWorkpiecePut">WorkplanSetupFixtureWorkpiecePut</a>
function places the workplan/workpiece onto the fixture. For example,
the workpiece maybe clamped into the middle of the fixture
vice.

<li>The <a href="#WorkplanSetupFixtureMountPut">WorkplanSetupFixtureMountPut</a>
function places the fixture onto the machine tool. For example, the
fixture may be placed in the middle of the machine tool bed.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a workplan.
</UL>


<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetupFixtureWorkpiecePut></a>
<a name=WorkplanSetupFixtureWorkpieceGet></a>WorkplanSetupFixtureWorkpieceGet/Put()</h2>
<pre>
void <b>WorkplanSetupFixtureWorkpieceGet</b> (
	System::Int64 plan_id,
	[System::Runtime::InteropServices::Out] double %x,
	[System::Runtime::InteropServices::Out] double %y,
	[System::Runtime::InteropServices::Out] double %z,
	[System::Runtime::InteropServices::Out] double %i,
	[System::Runtime::InteropServices::Out] double %j,
	[System::Runtime::InteropServices::Out] double %k,
	[System::Runtime::InteropServices::Out] double %a,
	[System::Runtime::InteropServices::Out] double %b,
	[System::Runtime::InteropServices::Out] double %c
	);

void <b>WorkplanSetupFixtureWorkpiecePut</b> (
	System::Int64 plan_id,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkplanSetupFixtureWorkpieceGet()</b> function gets the
coordinates where the workpiece is placed on the fixture.

<P>The <b>WorkplanSetupFixtureWorkpiecePut()</b> function completes
the chain of connections by defining where the workpiece is to be
placed on the fixture.


<h3>Arguments</h3>
<DL class=termdefs>
<DT>wp_id: <DD>  The identity of the workplan.
<DT>x, y, z: <DD> The origin of the placement.
<DT>i, j, k: <DD> The Z axis direction of the placement.
<DT>a, b, c <DD>The X axis direction of the placement.
</DL>

<h3>Related Functions</h3>
<UL>
<li>The <a href="#WorkplanSetupPut">WorkplanSetupPut</a> function
defines the coordinate system of the workplan. For example, the
workpiece may be turned over so that the bottom face is milled in this
setup.
<li>The <a href="#WorkplanSetupFixtureWorkpiecePut">WorkplanSetupFixtureWorkpiecePut</a>
function places the workplan/workpiece onto the fixture. For example,
the workpiece maybe clamped into the middle of the fixture vice.
<li>The <a href="#WorkplanSetupFixtureMountPut">WorkplanSetupFixtureMountPut</a>
function places the fixture onto the machine tool. For example, the
fixture may be placed in the middle of the machine tool bed.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The wp_id does not identify a workplan.
</UL>



<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanSetupPut></a>
<a name=WorkplanSetupGet></a>WorkplanSetupGet/Put()</h2>
<pre>
void <b>WorkplanSetupGet</b> (
	System::Int64 plan_id,
	[System::Runtime::InteropServices::Out] double %x,
	[System::Runtime::InteropServices::Out] double %y,
	[System::Runtime::InteropServices::Out] double %z,
	[System::Runtime::InteropServices::Out] double %i,
	[System::Runtime::InteropServices::Out] double %j,
	[System::Runtime::InteropServices::Out] double %k,
	[System::Runtime::InteropServices::Out] double %a,
	[System::Runtime::InteropServices::Out] double %b,
	[System::Runtime::InteropServices::Out] double %c
	);

void <b>WorkplanSetupPut</b> (
	System::Int64 plan_id,
	double x,
	double y,
	double z,
	double i,
	double j,
	double k,
	double a,
	double b,
	double c
	);
</pre>

<P>The <b>WorkplanSetupGet()</b> function gets the coordinates of a
Workplan setup and <b>WorkplanSetupPut()</b> function changes the
coordinates the setup.  The placement is given by a origin coordinate
and direction vectors for the Z axis and X axis.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan.
<DT>x, y, z: <DD> The origin of the placement.
<DT>i, j, k: <DD> The Z axis direction of the placement.
<DT>a, b, c: <DD> The X axis direction of the placement.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#WorkplanSetup">WorkplanSetup</a>: Define the setup of a
workplan.
<li><a href="#GetWorkpiecePlacement">GetPlacement</a>: Function used
to define the placement of a workpiece.
</UL>


<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a workplan.
</UL>




<!-- ================================ -->
<h2 class=rule>
<a name=WorkplanToSelective></a>WorkplanToSelective()</h2>
<pre>
System::Int64 <b>WorkplanToSelective</b> (
	System::Int64 wp_id
	);
</pre>

<P>The <b>WorkplanToSelective()</b> function converts a workplan to a
selective group.  A workplan is a sequence of workingsteps that share
a setup.  The components of a workplan are executed in sequence.  The
components can be a workingstep, an NC function or a nested
workplan. A selective workplan is a "choice" construct one where only
one of the components is executed.

<P>This one is the first executable to be &ldquo;enabled&rdquo;. By
default this will be the first executable in the workplan. Executables
can be enabled and disabled using the <a href="#SetCNCexportExecEnabled">SetCNCexportExecEnabled</a> and
<a href="#SetCNCexportExecDisabled">SetCNCexportExecDisabled</a>
functions.

<h3>Arguments</h3>
<DL class=termdefs>
<DT>plan_id: <DD> The identity of the workplan that is to be converted
to a selective.
</DL>


<h3>Related Functions</h3>
<UL>
<li><a href="#WorkplanFromSelective">WorkplanFromSelective</a>:
Function to convert a selective back into a regular workplan.
<li><a href="#SetCNCexportExecEnabled">SetCNCexportExecEnabled</a>:
Function to enable the execution of an executable in a workplan.
<li><a href="#SetCNCexportExecDisabled">SetCNCexportExecDisabled</a>:
Function to disable the execution of an executable in a workplan.
</UL>

<h3>Common Errors</h3>
<UL>
<li>No project open: An AP-238 file must be open - see
the <a href="#NewProject">NewProject</a> function.
<li>Bad identity: The plan_id does not identify a regular workplan.
</UL>


</div>

<div class="copyright">
  Copyright &copy; 2016 STEP Tools Inc. All Rights Reserved.<br>
</div>
</BODY>
</HTML>
